#! Become 2% of THE Django Developer
We will learn the most advanced topics of Backend development. Write Powerful Scalable code with proper test cases latest tech stack like Redis, Elastic Search, Kibana, Celery, Sockets etc.

#? Python 

1. Python is a high level programming language
2. Used in various applications like web development, Data Science, Machine Learning, AI, IoT, Game Development, Business Applications, etc.
3. Some companies that use python include Google, Amazon, Facebook, Netflix, Uber, etc.

#? Python Installation

1. For Windows: Download Python from https://www.python.org/downloads/ and keep all the default options along with Add to Path.
2. For Linux: sudo apt install python3
3. For MacOS: brew install python

#? Python2 vs Python3
1. Python2 is the legacy version of Python and Python3 is the latest version of Python.
2. Performance: Python3 is faster than Python2.
3. Backward compatibility: Python3 is backward compatible with Python2.
4. Libraries: Python3 has more libraries than Python2.

#? Python Operators
1. Arithmetic Operators: +, -, *, /, %, //, **
2. Assignment Operators: =, +=, -=, *=, /=, %=
3. Comparison Operators: ==, !=, >, <, >=, <=
4. Logical Operators: and, or, not
5. Identity Operators: is, is not
6. Membership Operators: in, not in
7. Bitwise Operators: &, |, ^, ~, <<, >>
8. Special Operators: lambda, yield

#? Python Conditions
1. if, elif, else
2. nested if
3. multiple conditions with and, or, not

#? Python Loops
1. for loop
2. while loop
3. break statement
4. continue statement
5. pass statement
6. Combination of break and continue statements

#? Python Data Structures
1. Lists - mutable ordered collection of elements
    * Attributes: len(), index()
    * Operations: append(), remove(), sort()
2. 2D Lists - lists containing other lists
    * Attributes: len() (for rows), len(matrix1) (for columns)
    * Operations: indexing, slicing, modifying elements
3. Dictionaries - key-value pairs
    * Attributes: keys(), values(), items()
    * Operations: add key-value pair, remove key
4. Tuples - immutable ordered collection of elements
    * Attributes: count(), index()
    * Operations: concatenation
5. Sets - unordered collection of unique elements
    * Operations: add(), remove(), check membership
6. Strings - sequence of characters
    * Operations: upper(), lower(), count(), startswith(), endswith(), replace()

#? Python Functions
1. Functions - basic function definition and call
2. Lambda functions - concise anonymous functions
3. Recursive functions - functions calling themselves
4. Default arguments - providing default values for function parameters
5. Keyword arguments - passing arguments by name
6. args and kwargs - handling variable number of positional and keyword arguments
7. Scope in Python - global variables, local variables, and modifying variables in enclosing scopes

#? Advanced Python - Object Oriented Programming
1. Classes and Objects - defining classes and creating instances
2. Class Attributes, Methods and variables - using class-level attributes and methods
3. Constructors - initializing objects with init method
4. Constructor Overloading - simulating constructor overloading (Python doesn't support true overloading)
5. Inheritance and Polymorphism - creating base and derived classes, demonstrating polymorphic behavior
6. Abstraction and Encapsulation - hiding internal details and protecting data
7. Static Methods and Class Methods - using @staticmethod and @classmethod decorators

#? Advanced Python - Threads
1. The problem that threads solve - concurrent execution of tasks which helps a program to perform multiple operations simultaneously rather than sequentially one after the other.
2. Creating threads with run(), start(), and join() methods.
3. Passing arguments to threads using lambda functions.
4. The difference between threads and processes (using multiprocessing).
5. The difference between run() and start() methods of threads. 
6. Creating threads using custom classes.
7. Create and solve real world example of downloading multiple images using threads -> Refer 09-python-threads-image-downloader.py

Key Differences between run(), start() and join() Methods:

a) Execution Context:
    * start() initiates the thread's execution.
    * run() defines what the thread does.
    * join() waits for the thread to finish.
b) Timing:
    * start() is typically called first, followed by join().    
    * run() is called automatically by start().
c) Blocking Nature:
    * start() is non-blocking.
    * join() is blocking, waiting for the thread to complete.
d) Return Value:
    * start() returns None.
    * run() doesn't return anything directly; its contents determine the output.
    * join() always returns None 3.

In summary, start() initiates the thread, run() defines its behavior, and join() ensures the main program waits for the thread to complete before continuing. Understanding these methods is crucial for proper thread management in Python.

* threading.current_thread().name is used to get the name of the current thread.
* threading.enumerate() returns a list of all currently active running threads.
* threading.get_ident() returns the unique identifier id of the current thread.

----------------------------------------------------------------------------------------------------------------------------------------

Here's a concise point and subpoint-wise answer combining the information from both answers:

#! What is Django?

- High-level Python web framework
- Often called "batteries included" due to comprehensive features
- Enables rapid development of secure and maintainable websites

#! Benefits of Django

1. Rapid Development
   - Follows MTV (Model-Template-View) architecture
   - Rich set of built-in features reduces third-party package needs

2. Security
   - Built-in security features (CSRF protection, clickjacking protection, XSS attack prevention)
   - Regular updates patch vulnerabilities promptly

3. Scalability
   - Designed to handle high traffic and large datasets efficiently
   - Supports asynchronous processing for long-running tasks

4. Extensive Libraries and Tools
   - Powerful ORM (Object-Relational Mapping) system
   - Flexible authentication and authorization system
   - Robust admin interface out of the box

5. Community and Ecosystem
   - Large and active community
   - Extensive documentation and tutorials available

6. Flexibility
   - Suitable for both small and large-scale applications
   - Modular architecture allows customization

7. Testing Framework
   - Built-in testing tools (unittest, test cases)

8. Internationalization (i18n) and Localization (l10n)
   - Built-in support for internationalizing projects

9. Database Agnostic
   - Supports multiple database backends out of the box

#! Why Prefer Django?

1. "Batteries Included"
   - Many built-in features save development time
   - Ready-to-use components reduce boilerplate code

2. Security Out of the Box
   - Reduces risk of common web vulnerabilities

3. Large Community and Ecosystem
   - Easy to find solutions or hire developers familiar with Django
   - Extensive third-party packages available

4. Scalability and Performance
   - Designed for high traffic and large datasets
   - Supports asynchronous processing

5. Rapid Prototyping
   - Allows quick development of prototypes and MVPs

6. Learning Curve
   - Steep initially, but efficient once mastered

7. Cross-platform Compatibility
   - Runs on Windows, macOS, and Linux

8. Extensibility
   - Custom apps and middleware extend functionality

9. ORM (Object-Relational Mapping)
   - High-level interface for database queries

10. Admin Interface
    - Powerful admin interface saves significant development time

11. Testing Framework
    - Built-in testing tools ensure code quality

12. Modular Architecture
    - Allows building complex applications with reusable components

13. Multiple Database Support
    - Connects to different types of databases simultaneously

14. Caching with Redis
    - Built-in cache framework supports Redis backend

15. RabbitMQ Integration
    - Supports AMQP protocol, compatible with RabbitMQ

16. Load Testing with Locust
    - Can be integrated for load testing

17. Testing with Pytest
    - Works well with pytest for unit and integration testing

18. Django REST Framework (DRF)
    - Built on top of Django, focuses on API development

19. Admin Panel
    - Powerful admin interface for managing data models

20. ORM
    - Abstracts database operations for database-independent code

21. Docker and Deployment with Nginx
    - Can be containerized using Docker
    - Works well with Nginx as reverse proxy and load balancer

22. Celery
    - Built-in task queueing system for asynchronous processing

23. Not Good for Simpler Projects
    - Better suited for complex features rather than simple projects

24. Steep Learning Curve
    - Requires knowledge of entire structure before starting

This concise overview covers the key points about Django, its benefits, and why it's preferred, while also mentioning some potential drawbacks.

#? Building your first django project and application:

1. Create a virtual environment using command: python3 -m venv venv
2. Activate the virtual environment: source venv/bin/activate
3. Install django: pip install django
4. Create a new project: django-admin startproject myfirstproject .
5. Create a new application: python manage.py startapp myfirstapp
6. Run the development server: python manage.py runserver
7. To run the development server in debug mode: python manage.py runserver --debug
8. To run the development server in debug mode with an IP address and port: python manage.py runserver --debug 0.0.0.0:8000
9. To create a superuser account: python manage.py createsuperuser
10. Store requirements in requirements.txt: pip freeze > requirements.txt

#? Django project and application files to know about:

1. settings.py: Configuration for the Django project.
2. urls.py: URL patterns for the Django project.
3. wsgi.py: WSGI server configuration for the Django project.
4. asgi.py: ASGI server configuration for the Django project.
5. manage.py: Command-line utility for managing the Django project.
6. models.py: Database models for the Django project.
7. forms.py: Form definitions for the Django project.
8. views.py: View functions for the Django project.
9. templates: HTML templates for the Django project.
10. static: Static files for the Django project.
11. migrations: Database migrations for the Django project.
12. tests: Unit and integration tests for the Django project.
13. admin.py: Admin interface for the Django project.
14. .env : Environment variables for the Django project.

#? Breaking Down Django Apps: What They are and How They Work:

1. We breakdown an project to various little apps each with a specific task.
2. Example: A Library Management system can have several apps like:
    * Books App
    * Authors App
    * Publishers App
    * Orders App
    * Members App
    * Borrowing App
    * Admin App, etc.

3. Each app has its own models, views, templates, and URLs.
4. Each app has its own database and can be accessed from the main project.
5. Each app has its own URL patterns and can be accessed from the main project.
6. Each app has its own templates and can be accessed from the main project.
7. Each app has its own static files and can be accessed from the main project.
8. Each app has its own migrations and can be accessed from the main project.
9. Each app has its own tests and can be accessed from the main project.

Here are some key differences and comparisons between WSGI and ASGI:

#? Key Points Comparing WSGI and ASGI

1. Purpose:
   - WSGI: Primarily for web servers
   - ASGI: For asynchronous application servers

2. Asynchronous Support:
   - WSGI: Synchronous only
   - ASGI: Supports both synchronous and asynchronous applications

3. Protocol:
   - WSGI: Uses a synchronous request-response model
   - ASGI: Uses an asynchronous event loop model

4. Framework Support:
   - WSGI: Supported by most traditional web frameworks (Django, Flask)
   - ASGI: Supported by newer asynchronous frameworks (FastAPI, Django Asynchronous)

5. Performance:
   - WSGI: Better suited for I/O-bound applications
   - ASGI: More efficient for CPU-bound tasks and real-time applications

6. Compatibility:
   - WSGI: Widely supported across various web servers
   - ASGI: Less widespread but growing in adoption

7. Use Cases:
   - WSGI: Ideal for traditional web applications
   - ASGI: Better suited for real-time applications (chat apps, gaming platforms)

8. Implementation:
   - WSGI: Simpler implementation due to synchronous nature
   - ASGI: More complex implementation due to asynchronous nature

9. Future-Proofing:
   - WSGI: May become outdated as more applications require real-time features
   - ASGI: Better positioned for future web application needs

10. Learning Curve:
    - WSGI: Easier to learn and implement
    - ASGI: Steeper learning curve due to asynchronous concepts

In summary, while WSGI remains relevant for traditional web applications, ASGI is becoming increasingly important for modern, high-performance web applications that require real-time features and efficient handling of concurrent requests.

Here are some key points comparing Daphne and Gunicorn:

#? Daphne vs Gunicorn

1. Purpose:
   - Daphne: ASGI server primarily for running Django Channels
   - Gunicorn: WSGI server for running traditional Django applications

2. Protocol Support:
   - Daphne: Supports HTTP/1.1, HTTP/2, and WebSockets
   - Gunicorn: Supports WSGI (not ASGI)

3. Use Cases:
   - Daphne: Ideal for real-time applications and WebSocket-based projects
   - Gunicorn: Better for traditional web applications with synchronous requests

4. Performance:
   - Daphne: Optimized for real-time and WebSocket applications
   - Gunicorn: Generally faster for standard WSGI applications

5. Integration:
   - Daphne: Designed to work with Django Channels
   - Gunicorn: Works with standard Django projects

6. Configuration:
   - Daphne: Simpler configuration focused on ASGI support
   - Gunicorn: More flexible configuration options for WSGI servers

7. Learning Curve:
   - Daphne: Steeper learning curve due to real-time features
   - Gunicorn: Easier to learn and use for traditional web apps

8. Compatibility:
   - Daphne: Primarily used with Django Channels
   - Gunicorn: Compatible with various Python web frameworks

9. Scalability:
   - Daphne: Good for scaling real-time applications
   - Gunicorn: Well-suited for scaling traditional web applications

10. Market Position:
    - Daphne: Growing in popularity for real-time Django applications
    - Gunicorn: Established as a standard WSGI server for Django projects

In summary, Daphne is specialized for real-time applications and WebSocket support, while Gunicorn remains a versatile choice for traditional Django web applications. The choice between them depends on the specific requirements of your project, particularly whether real-time features are needed.

#! Understanding URL's and Views

#? Understanding URL's and Views in Django
1. Views are the python functions or classes that handle HTTP requests and return HTTP responses.
2. URLs map HTTP requests to views.
3. URLs are defined in the application's urls.py file which are then used in the project's urls.py file.
4. URLs can be defined using regular expressions or string patterns.
5. Views are defined in the application's views.py file.
6. Views are responsible for performing logic like rendering templates, processing forms, returning JSON responses, etc.
7. Views are associated with URLs using URL patterns.

#? Building Dynamic URL Patterns in Django
Example of building a dynamic URL pattern: 
   * http://domain.com/contact/<int:contact_id> where contact_id is an dynamic integer parameter according to which lets say tables will be plotted and data will be fetched

#TODO Approach - 1:

* Define a URL pattern with a dynamic parameter. 
** urls.py **
"
path('dynamic_route/<int:number>', dynamic_route, name='dynamic_route'),
"
** views.py **
"
def dynamic_route(request, number):
    for i in range(0,10):
        print(f"{number} * {i+1} = ", (i+1)*number)
    return HttpResponse(f"Hello, the number is {number}")
"

#TODO Approach - 2:

* Define a URL pattern with a dynamic parameter using a regular expression which will use re_path rather than path
Here's a simple example of defining a URL pattern with a dynamic parameter using a regular expression in Django:
** urls.py **

```
from django.urls import re_path
from . import views

urlpatterns = [
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
]
```

Key points:
1. We use `re_path()` to allow regular expressions in our URL pattern.
2. The regular expression `r'^articles/(?P<year>[0-9]{4})/$'` captures:
   - `^articles/` matches the start of the URL path
   - `(?P<year>[0-9]{4})` captures exactly 4 digits as the year
   - `$` ensures the URL ends exactly there
3. The captured group `<year>` will be passed as an argument to the view function.
4. This pattern will match URLs like `/articles/2025/`.
5. The corresponding view function would look something like:

```
def year_archive(request, year):
      # Handle requests for articles from the specified year
      return HttpResponse(f"Articles from {year}")
```

#! Templates and Static Files

#? How to render HTML Templates and use context in Django
1. Define a template in the templates directory.
2. Create a context dictionary to pass data to the template in your view.
3. Render the template using the context dictionary.
4. Have a url pattern that maps to your view.

** sample code for view **
```
from django.shortcuts import render

def index(request):
    # Define context dictionary
    context = {
        'title': 'Welcome to My Site',
        'message': 'This is the home page',
        'current_year': 2023,
    }
    
    # Render template with context
    return render(request, 'index.html', context)
```
** sample code for templates **
```
<h1>{{ title }}</h1>
<p>{{ message }}</p>
<p>Current year: {{ current_year }}</p>
```

#? Understanding Django Templates in Detail
1. Templates are HTML files that contain placeholders for dynamic content.
2. Context is used to pass data to the template.
3. Some of the most used Django template tags include:
a) {% for %} and {% endfor %} for loops
b) {% if %} and {% else %} for conditional statements
c) {% extends %} to inherit from a parent template
d) {% block %} and {% endblock %} to define a block of content that can be overridden in child templates
e) {% with %} to create a temporary context
f) {% url %} to generate URLs
g) {% include %} to include another template
h) {{ | }} is pipe operator used to manipulate data, for example {{ user.first_name|upper }} or {{ users|length }} where users will be a list of users
i) {% load static %} to load and serve static files
j) {% load i18n %} to load translation files
k) {% load crispy_forms_tags %} to load crispy forms tags
l) {% csrf_token %} to generate a CSRF token for forms protection
m) {% now %} to get the current date and time
n) {% comment %} and {% endcomment %} to add comments in the template

For more, refer => "https://docs.djangoproject.com/en/5.1/ref/templates/builtins/"
You can also create your own custom template tags, refer => "https://docs.djangoproject.com/en/5.1/howto/custom-template-tags/"

#! Database Setup in Django

Django has support for several popular databases, including:
a) MySQl
b) PostgreSQL
c) SQLite

1. For now we will be using PostgreSQL, I am using Linux so we need to install PostgreSQL, its dependecies and pgAdmin
a) For PostgreSQL: "https://www.postgresql.org/download/linux/ubuntu/" and follow the steps under "To manually configure the Apt repository, follow these steps"
b) For pgAdmin: "https://www.pgadmin.org/download/pgadmin-4-apt/" and follow the steps under "To use this repository, run the following commands"

#TODO - Installation Guide for PostgreSQL and pgAdmin => "https://www.youtube.com/watch?v=UGfteFq_6Co"

2. Now we will setup our database with our Django project but before that, create a database and set that in NAME variable under DATABASES in settings.py
a) For SQLite:
```
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
```
b) For PostgreSQL: Download PostgreSQL Client using command "pip install psycopg2-binary"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '5432',
    }
}
```
c) For MySQL: Download MySQL Client using command "pip install mysqlclient"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '3306',
    }
}
```

3. Now we will run Django command "python3 manage.py migrate" to migrate our database.

#! Django Models

Here's a more detailed version of the notes on Django models, incorporating the additional information from the search results:

#? Defining Models and Fields

1. Model Definition:
   - Create a class that inherits from `models.Model`
   - Define fields as attributes of the model class
   - Use `Meta` inner class for metadata about the model

2. Common Fields:
   - CharField: For short text strings
   - TextField: For longer text content
   - IntegerField: For whole numbers
   - FloatField: For decimal numbers
   - DateField: For dates
   - BooleanField: For true/false values
   - ForeignKey: For relationships with other models
   - ManyToManyField: For many-to-many relationships
   - ImageField: For image uploads
   - FileField: For file uploads
   - EmailField: For email addresses
   - SlugField: For URL-friendly strings
   - DurationField: For durations
   - IPAddressField: For IP addresses
   - GenericIPAddressField: For both IPv4 and IPv6 addresses
   - PositiveIntegerField: For positive integers
   - PositiveSmallIntegerField: For small positive integers
   - PositiveFloatField: For positive floating-point numbers
   - DateTimeField: For dates and times
   - TimeField: For times
   - UUIDField: For universally unique identifiers
   - XMLField: For storing XML data
   - JSONField: For storing JSON data
   - BitField: For storing single boolean values in a compact way
   - AutoField: Automatically increments for each new record
   - BigAutoField: Similar to AutoField but uses a larger range
   - SmallIntegerField: For small integers
   - FilePathField: For file paths
   - RelatedManager: For managing related objects

** sample code for models.py **
```
from django.db import models


class College(models.Model):
    college_name = models.CharField(max_length=100)
    college_address = models.CharField(max_length=100)


class Student(models.Model):
    gender_choices = (("Male", "Male"), ("Female", "Female"))
    college = models.ForeignKey(
        College, on_delete=models.CASCADE, null=True, blank=True
    )
    name = models.CharField(max_length=100)
    mobile_number = models.CharField(max_length=12)
    email = models.EmailField()
    gender = models.CharField(max_length=10, choices=gender_choices, default="Male")
    student_bio = models.TextField()
    date_of_birth = models.DateField()
    student_profile_image = models.ImageField(
        null=True, blank=True, upload_to="student_profile_images/"
    )
    student_file = models.FileField(null=True, blank=True, upload_to="student_files/")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

#? Model Relationships

1. One-to-One Relationships:
   - Use `OneToOneField` to establish a one-to-one relationship
   - Useful for extending existing models without duplicating fields

2. One-to-Many Relationships:
   - Use `ForeignKey` field in one model to reference another model
   - Can specify `on_delete` parameter to handle cascading deletes

3. Many-to-Many Relationships:
   - Use `ManyToManyField` to establish many-to-many relationships
   - Can specify intermediate tables for complex relationships

4. Reverse Relationships:
   - Access related objects using `model_name_set` attribute
   - Use `ForeignKey.related_model` to get the related model class

* refer myfirstapp/firstmodels.py for more details

#? ORM (Object-Relational Mapping)

1. Definition:
   - Abstraction layer between Python code and database
   - Allows working with data as objects rather than writing SQL queries

2. Benefits:
   - Simplifies database operations
   - Provides a consistent interface across different databases
   - Reduces boilerplate code
   - Improves security by reducing direct SQL injection risks

3. Key Features:
   - Automatic creation of database schema from models
   - QuerySet API for filtering, sorting, and manipulating data
   - Support for complex queries using Django's ORM syntax
   - Raw SQL queries for performance-critical operations

4. QuerySet:
   - Lazy evaluation of database queries
   - Supports chaining of methods for complex queries using Q objects
   - Methods like `filter()`, `exclude()`, `order_by()`, etc.

5. Model Managers:
   - Custom managers can be defined to modify or extend QuerySet behavior
   - Useful for adding custom methods to model instances

6. Abstract Models:
   - Define a base class for models with shared fields
   - Inherit from `AbstractBaseUser` for custom user models

7. Model Methods:
   - Define methods within the model class for business logic
   - Useful for complex validations or calculations

8. Model Fields:
   - Use `choices` parameter for field values with predefined options
   - Implement custom validation using `clean()` method

9. Model Meta Options:
   - Specify database table name and app label
   - Set default values for fields
   - Configure index settings for fields

10. Model Signals:
    - Connect to signals like `pre_save`, `post_save`, etc., for model events
    - Useful for triggering actions before or after model changes


* After "python3 manage.py makemigrations" run "python3 manage.py migrate", open shell using "python3 manage.py shell" and insert few dummy data in database

#! Building Forms in Django

Django forms has various limitations and in actual project we prefer HTML forms over django forms. For pretty django forms we should use third party packages like "django-crispy-forms". 

#? Beginner's Guide to Django Forms

1. Introduction to Forms:
   - Forms are used to collect user input
   - They consist of fields and widgets
   - Django provides built-in form classes and widgets

2. Creating a Simple Form:
   - Import necessary modules
   - Define form fields
   - Create a form instance

3. Rendering Forms:
   - Use `as_p()` method to render form as paragraphs
   - Use `as_table()` method to render form as table
   - Use `as_ul()` method to render form as unordered list

4. Handling Form Data:
   - Access form data using `form.cleaned_data`
   - Use `is_valid()` method to check if form is valid

5. Customizing Forms:
   - Add custom validation
   - Set initial values
   - Make fields required

6. Form Fields:
   - CharField: For text input
   - IntegerField: For integer input
   - ChoiceField: For select dropdowns
   - DateTimeField: For date/time inputs
   - FileField: For file uploads

7. Form Widgets:
   - Textarea for multi-line text
   - CheckboxSelectMultiple for multiple selections
   - SelectDateWidget for date selection

8. Form Validation:
   - Built-in validation methods
   - Custom validation using `clean()` method

9. Form Security:
   - Use CSRF protection
   - Prevent cross-site scripting (XSS)

10. Form Types:
   - ModelForm for working with models
   - Form for custom forms

#? HTML Forms in Django

1. Basic Structure:
```
<form action="{% url 'view_name' %}" method="post">
      {% csrf_token %}
      {{ form.as_p }}
      <input type="submit" value="Submit">
</form>
```

2. Form Actions:
   - Use `{% url %}` tag to generate URLs
   - Specify `method` attribute (GET or POST)

3. Form Fields:
   - Text inputs: `<input type="text" name="field_name">`
   - Checkboxes: `<input type="checkbox" name="field_name">`
   - Radio buttons: `<input type="radio" name="field_name">`

4. File Uploads:
```
<form enctype="multipart/form-data">
      {{ form.as_p }}
</form>
```

5. Form Styling:
   - Use CSS classes for styling
   - Customize widget appearance

6. Form Submission:
   - Handle form submission in views
   - Process and validate form data

7. Error Handling:
   - Display validation errors
   - Show custom error messages

8. Form Libraries:
   - jQuery Form Plugin for AJAX submissions
   - Bootstrap Forms for responsive designs

Summary:
a) Make forms.py and use either DjangoForm or ModelForm
b) In template use form.as_p() to render form as paragraph and use csrf token
c) In view, use form.cleaned_data to access form data and is_valid() to check if form is valid
d) In view, use form.save() to save form data to database if the form is valid which will raise exception if form is invalid
e) If not using django forms and directly using HTML forms, get all the data from the request.POST and save it to the database using Model_name.objects.create()

#! Django Models Level 2 (Advanced)

#TODO Create vs Save vs Get_Or_Create method in Django (Interview Question)

Here are the key points comparing Create, Save, and Get_or_Create methods in Django:

#? Create Method

1. Usage:
   - `Model.objects.create(**kwargs)`
   - Creates a new object and saves it to the database in one step

2. Advantages:
   - More concise and readable for simple object creation
   - Automatically handles saving the new object

3. Behavior:
   - Always performs an INSERT operation
   - Returns the newly created object instance

4. Use cases:
   - Handling form submissions
   - Data imports where data is ready to save immediately

#?  Save Method

1. Usage:
   - `object.save()`
   - Saves an existing object instance to the database

2. Advantages:
   - Used when you already have an object instance
   - Allows for custom logic before saving

3. Behavior:
   - Performs either INSERT (new object) or UPDATE (existing object)
   - Requires manual object instantiation

4. Use cases:
   - Modifying existing objects instance
   - Custom validation before saving

#? Get_or_Create Method

1. Usage:
   - `Model.objects.get_or_create(**kwargs)`
   - Attempts to retrieve an object matching the kwargs, creating it if not found

2. Advantages:
   - Combines retrieval and creation in one step
   - Useful for ensuring object existence before use

3. Behavior:
   - First tries to get an existing object
   - If not found, creates and saves a new object

4. Use cases:
   - Ensuring object exists before use (e.g., in views)
   - Optimizing database queries

Key differences:
- Create always creates new objects
- Save works on existing objects instance or new ones
- Get_or_Create retrieves if possible, else creates

Choose based on your specific use case and object lifecycle requirements.

#TODO Use Faker for Inserting Dummy Data into your Django Models

1. pip install faker
2. Create a seed_db.py file and write code to insert dummy data into your models
#! Approach 1
3. Open shell and run dbSeeder() after importing it
#! Approach 2
4. Create a new file in your app's management/commands directory named "seeder.py"
5. Then use command "python manage.py seeder --number=20"
6. See your custom made commands by using "python3 manage.py"

#TODO Master Django ORM Lookups: Advanced Query Techniques and Searching

### 1. Chaining Queries

- Allows building complex queries step-by-step
- Enables highly specific queries while maintaining readability
- Examples:
  - Combining filters and ordering
  - Chaining aggregations
```
users = User.objects.filter(is_active=True).exclude(email__endswith='.com').order_by('-date_joined')
```

### 2. F() Expressions

- Allow performing database operations using values from the database
- Useful for maintaining data integrity and efficient updates
- Examples:
  - Increasing a value
  - Calculating discounts
```
User.objects.filter(age=F('current_age') + 1)
```

### 3. Q() Objects

- Enable building complex queries with logical OR and AND operators
- Useful for combining conditions dynamically
- Examples:
  - Constructing complex queries
  - Dynamic search
```
q1 = Q(first_name__startswith='J')
q2 = Q(last_name__endswith='sen')
result = User.objects.filter(q1 | q2)
```

### 4. Raw SQL Queries

- Allow executing raw SQL queries when needed
- Use `raw()` method for safe execution
- Examples:
  - Retrieving data
  - Updating data
  - Mapping results to model objects
```
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SELECT username, email FROM auth_user WHERE age > 30")
    users = [User(username=row[0], email=row[1]) for row in cursor.fetchall()]
```

### 5. Advanced Query Techniques

- Using `annotate()` with expressions
- Combining multiple lookups
- Using `values()` and `values_list()`
- Creating custom managers
```
from django.db.models import F, ExpressionWrapper, DecimalField

User.objects.update(age=ExpressionWrapper(F('age') + 1, output_field=DecimalField()))
```

### 6. Searching Techniques

- Full-text searching
- Complex search queries using Q() objects
- Search with pagination
```
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank

results = Post.objects.annotate(
    search_vector=SearchVector('title', 'content')
).filter(search_vector=SearchQuery('Django tutorial')).order_by('-search_rank')
```

### 7. Performance Optimization

- Using select_related() and prefetch_related()
- Avoiding n+1 query problem
- Caching strategies
```
posts = Post.objects.select_related('category').prefetch_related('tags')
```

### 8. Working with Dates and Times

- Date range queries
- Calculating time differences
- Formatting dates/times
```
from django.utils.timezone import now

recent_posts = Post.objects.filter(created_at__range=(now() - timedelta(days=7), now()))
```

These points cover various advanced techniques in Django ORM, from complex querying methods to performance optimization and specific use cases like full-text searching and working with dates.

#TODO Aggregate and Annotations in Django

Here are brief but detailed notes on Aggregate and Annotations in Django, organized with points and subpoints:

#? Aggregate

1. Definition:
   - Performs aggregation operations on QuerySets
   - Returns a dictionary with aggregated results

2. Usage:
   - Used with `aggregate()` method
   - Typically used for summary statistics

3. Examples:
   - Count: `Count('id')`
   - Sum: `Sum('price')`
   - Avg: `Avg('price')`
   - Min: `Min('price')`
   - Max: `Max('price')`

4. Key characteristics:
   - Collapses entire QuerySet into a single value
   - Cannot be chained with other QuerySet methods
   - Useful for getting overall statistics

5. Syntax:
```
result = Model.objects.aggregate(Sum('field'))
```

#? Annotation

1. Definition:
   - Adds computed fields to QuerySet results
   - Returns a new QuerySet with annotated fields

2. Usage:
   - Used with `annotate()` method
   - Can be chained with other QuerySet methods

3. Examples:
   - Count related objects: `Count('related_model')`
   - Sum related field: `Sum('related_model__field')`
   - Case expressions: `Case(..., When(...))`

4. Key characteristics:
   - Adds new fields to each object in the QuerySet
   - Preserves the ability to chain with other QuerySet methods
   - Useful for including derived fields in results

5. Syntax:
```
books = BookData.objects.annotate(chapters_count=Count('bookchapterdata'))

books = BookData.objects.annotate(total_pages=Sum('bookchapterdata__pages')) # when using foreign key

books = BookData.objects.annotate(
    popularity_status=Case(
        When(chapters_count__gt=10, then='Popular'),
        default='Not Popular',
        output_field=CharField()
    )
)
```

# Comparison
1. Purpose:
   - Aggregate: Summary statistics
   - Annotation: Derived fields for each object

2. Return value:
   - Aggregate: Single dictionary
   - Annotation: New QuerySet with additional fields

3. Chaining:
   - Aggregate: Not chainable
   - Annotation: Chainable with other QuerySet methods

4. Use cases:
   - Aggregate: Overall statistics, reporting
   - Annotation: Including derived fields in results, complex queries

5. Performance:
   - Aggregate: Generally faster for large datasets
   - Annotation: May impact performance for large datasets

Both Aggregate and Annotation are powerful tools for manipulating QuerySets in Django, serving different purposes in data analysis and query construction.

#TODO Subquery in Django

Here are some brief but detailed notes on using subqueries in Django, with examples:

#? Understanding Subqueries

- A subquery is a query nested within another query
- Allows retrieving data from one table based on results of another query
- Useful for complex filtering, aggregation, and joining operations
- Can lead to more concise and efficient code compared to multiple separate queries

#? Key Points

- Subqueries are part of `django.db.models`
- Commonly used with `Subquery()` and `OuterRef()` objects
- Can be used for filtering, annotating, and other query operations
- Often more efficient than multiple separate queries

#? Examples

1. Filtering based on subquery:

```
from django.db.models import Subquery, OuterRef

recent_posts = Post.objects.filter(published_date__gte=datetime.now()-timedelta(days=30))
popular_authors = Author.objects.filter(post__in=Subquery(recent_posts.values('author')))
```

2. Annotating with subquery:

```
from django.db.models import Count, Subquery

post_counts = Post.objects.filter(author=OuterRef('pk')).values('author').annotate(count=Count('id')).values('count')
authors_with_post_counts = Author.objects.annotate(post_count=Subquery(post_counts))
```

3. Using subquery with exists:

```
from django.db.models import Exists, OuterRef

active_users = User.objects.filter(last_login__gt=datetime.now()-timedelta(days=30))
inactive_user_ids = User.objects.exclude(
    Exists(active_users.filter(id=OuterRef('id')))
).values_list('id', flat=True)
```

#? Best Practices

- Use subqueries when dealing with complex relationships or aggregations
- Prefer subqueries over multiple separate queries for efficiency
- Combine with other Django ORM features like annotations and filters
- Test performance impact of subqueries on your specific dataset

By leveraging subqueries effectively, you can write more efficient and expressive database queries in Django.

#TODO Overwrite Save() Method in Django

Here are some brief but detailed notes on overriding the save() method in Django models, with examples:

#? Understanding save() Method

- The save() method is inherited from models.Model and is called when creating or updating a model instance
- It's executed when saving through admin interface, shell, or other methods
- Can be overridden to add custom behavior before or after saving to the database

#? Key Points

- Override save() in your model class
- Call super().save() at the end to actually save the instance
- Be cautious as errors in save() can prevent database saves

#? Examples

1. Auto-generating a slug:

```
from django.db import models
from django.utils.text import slugify

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(self.title)
        super().save(*args, **kwargs)
```

2. Resizing an image before saving:

```
from django.db import models
from PIL import Image

class Product(models.Model):
    name = models.CharField(max_length=100)
    image = models.ImageField(upload_to='products/')
    
    def save(self, *args, **kwargs):
        if self.image:
            img = Image.open(self.image.path)
            img.thumbnail((100, 100))
            img.save(self.image.path)
        super().save(*args, **kwargs)
```

3. Sending email after save:

```
from django.db import models
from django.core.mail import send_mail

class Appointment(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

    def save(self, *args, **kwargs):
        if self.pk is None:  # New instance
            send_mail(
                'New Appointment',
                f'Name: {self.name}\nEmail: {self.email}',
                'admin@example.com',
                ['notifications@example.com'],
                fail_silently=False,
            )
        super().save(*args, **kwargs)
```

#? Best Practices

- Use signals (pre_save, post_save) instead of overriding save() when possible
- Handle exceptions carefully in overridden save() methods
- Consider using properties or separate methods for complex logic
- Be aware of potential performance impacts with database operations in save()

* Refer Products model in models.py and generateSlug() from my utils.py

By understanding how to override the save() method, you can add custom behavior to your Django models, but use this feature judiciously as it can lead to more complex code if overused.

#TODO -> Bulk Create, Bulk Update and Bulk Delete in Django

#? Understanding Bulk Operations

- Bulk operations allow performing multiple database operations in a single query
- Significantly improves performance for large datasets compared to individual operations
- Available for create, update, and delete operations

#? Key Points

- Use `bulk_create()`, `bulk_update()`, and `bulk_delete()` methods
- Requires a list of model instances to operate on
- Can specify fields to update for bulk_update()
- Batch size can be controlled to optimize performance

#? Examples

1. Bulk Create:

```
new_objects = [Model(field1=value1, field2=value2) for _ in range(100)]
Model.objects.bulk_create(new_objects)
```

2. Bulk Update:

```
objects_to_update = Model.objects.all()[:100]
Model.objects.bulk_update(objects_to_update, ['field1', 'field2'])
```

3. Bulk Delete:

```
objects_to_delete = Model.objects.filter(condition).all()
Model.objects.bulk_delete(objects_to_delete)
```

#? Best Practices

- Use bulk operations for large sets of data to reduce database queries
- Be cautious with bulk delete as it permanently removes data
- Consider using transactions for atomicity in complex operations
- Profile performance to determine optimal batch sizes

#? Additional Features

- `ignore_conflicts=True` for bulk_create to skip existing entries
- `update_conflicts=True` for bulk_update to update existing entries
- `return_id=True` for bulk_create to return created IDs

* Refer bulk_operations_view from views.py
* Refer bulk_create_brands(), bulk_update_brands() and bulk_delete_brands() from my utils.py
* Refer bulk_operations.html from templates

By leveraging bulk operations, you can significantly improve the performance of data manipulation in Django, especially when dealing with large datasets.

#TODO -> Meta Class in Django

Here are some brief but detailed notes on the Meta class in Django models:

#? Understanding Meta Class

- The Meta class is an inner class within Django model classes
- Used to provide metadata and customization options for the model
- Optional, but commonly used to modify model behavior

#? Key Points

- Located inside the model class definition
- Provides various options to customize model behavior
- Does not inherit from any base class
- Accessed using model._meta syntax

#? Common Meta Options

1. Abstract models:
   ```
   class Meta:
       abstract = True
   ```

2. Table name:
   ```
   class Meta:
       db_table = 'custom_table_name'
   ```

3. Ordering:
   ```
   class Meta:
       ordering = ['-date_field']
   ```

4. Permissions:
   ```
   class Meta:
       permissions = (
           ('can_view_reports', 'Can view reports'),
       )
   ```

5. Verbose name:
   ```
   class Meta:
       verbose_name = 'User Account'
   ```

6. App label:
   ```
   class Meta:
       app_label = 'auth'
   ```

7. Proxy models:
   ```
   class Meta:
       proxy = True
   ```

#? Best Practices

- Use Meta for model-specific configurations
- Keep Meta simple and focused on model metadata
- Document custom Meta usage clearly
- Be consistent across similar models

#? Example

```
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)

    class Meta:
        ordering = ['-title']
        verbose_name = 'Book Title'
        db_table = 'books_custom'

    def __str__(self):
        return self.title
```

By utilizing the Meta class effectively, you can customize and enhance your Django models, improving their functionality and readability.

#TODO -> Soft Delete and Model Managers in Django

1. Soft Delete: This feature allows you to mark records as deleted without permanently removing them from the database. Instead, they are marked as deleted and can be restored if needed.
2. Model Managers: Model managers provide additional functionality for querying and manipulating your models. They can be used to perform complex queries or custom operations on your models.

```
class SkillManager(models.Manager):

    def get_queryset(self) -> models.QuerySet:
        return super().get_queryset().filter(is_deleted=False)


class Skills(models.Model):
    skill_name = models.CharField(max_length=100)
    is_deleted = models.BooleanField(default=False)

    objects = SkillManager() #! Setting SkillManager as default manager
    new_manager = models.Manager() #! Creating new manager and setting old default manager here

    def __str__(self):
        return self.skill_name
```

------------------------------------------------------------------------------

#! Project: Expense Tracker 

1. In this project, we will cover CRUD operations, aggregate functions, login logout and registration of users using Django. Also professional looking UI for templates.
2. Project: Expense
3. App: Tracker

------------------------------------------------------------------------------

#! Project: Full Text Search - Search Query, Search Rank and Search Vector. Also Implement TrigamSimilarity in Django

1. In this project, we will develop a Full Text Search algorithm using Search Query, Search Rank and Search Vector.
2. This will be possible only with Postgres Database as it supports search query, search rank and search vector.
3. Rank wise searching is needed to find the most relevant results and will be much faster compared to traditional searching.
4. We will use Django Debug Toolbar to see the time taken to execute the queries.

#? Full Text Search Algorithm
Full-text search (FTS) is a technique for searching and retrieving relevant documents based on the contents of the text. It involves three key components: the search query, which is the user's input; the search rank, which determines the relevance of each document based on factors like term frequency (TF) and inverse document frequency (IDF); and the search vector, which represents the query and documents as mathematical vectors for comparison. These elements work together to efficiently match and rank documents, using methods like TF-IDF, cosine similarity, and Boolean logic to provide accurate and relevant search results.

#* Full Text Search is a smaller version of Elastic Search. Full Text Search is feasible for low end servers whereas Elastic Search is used for large scale high end servers. Elastic Search requires minimum 8gb of RAM.

#TODO Add "django.contrib.postgres" to INSTALLED_APPS in settings.py

#? Trigram Similarity
Used to introduce fuzziness thus finding similar words in the database. It is a faster alternative to FTS. 
Example: User will get outout if he searches for "Cement" or "Cemnt" with spelling mistake.

#TODO Go to terminal and type "sudo -u postgres psql -d fulltextsearch", after logging in use "CREATE EXTENSION IF NOT EXISTS pg_trgm;" and verify its installation using "\dx"

------------------------------------------------------------------------------

#! Django Admin Interface

#? Customizing the Django Admin

* Refer admin.py from djangoadmin project

#? Customizing the look and feel of the Django Admin

#! Approach 1
* pip install django-admin-interface
* Add admin_interface and colorfield to INSTALLED_APPS

#! Approach 2
* pip install django-grappelli
* Add grappelli to INSTALLED_APPS
* Add "path("grappelli/", include("grappelli.urls"))," to urlpatterns
* python3 manage.py collectstatic

------------------------------------------------------------------------------

#! Django Middleware

#? Understanding the Django Middleware Deeply and Customizing middleware in Django

#? What is Middleware?

- Middleware acts as a layer between the request and response cycles
- It allows adding functionality to every request/response without modifying views
- Middleware components are stacked and processed in order

#? Key Functions of Middleware

1. Filtering Requests
   - Reject invalid or malicious requests early
   - Example: CSRF protection middleware

2. Modifying Requests/Responses  
   - Adding data to requests
   - Altering responses
   - Example: Authentication middleware adds user info to requests

3. Logging and Analytics
   - Tracking request/response data
   - Storing metrics
   - Example: Usage tracking middleware

#? Middleware Structure

- Two main methods:
  1. `__init__(get_response)` - Called once when server starts
  2. `__call__(request)` - Called for each request/response cycle

- Optional additional methods:
  - `process_view()`
  - `process_exception()`
  - `process_template_response()`

#? Registering Middleware

- Added to `MIDDLEWARE` setting in `settings.py`
- Order matters - affects execution sequence

#? Writing Custom Middleware

```
class MyMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        # Pre-process logic
        response = self.get_response(request)
        # Post-process logic
        return response
```

#? Best Practices

- Keep middleware lightweight
- Use built-ins when possible
- Order carefully to avoid conflicts
- Consider performance implications

#? Examples

1. Basic middleware:

```
class LogTimeMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        start_time = time.time()
        response = self.get_response(request)
        end_time = time.time()
        print(f"Request took {end_time - start_time:.2f}s")
        return response
```

2. Authentication middleware:

```
class AuthenticationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        if 'user' not in request.session:
            # Redirect to login page
            pass
        return self.get_response(request)
```

1) Refer djangomiddleware project
2) Create middleware folder in project directory
3) Inside it create __init__.py and middleware.py
4) Create a middleware named IPBlockingMiddleware
5) Add "djmiddleware.middleware.middleware.IPBlockingMiddleware" to INSTALLED_APPS in settings.py
6) Write a view and url pattern to test it.

------------------------------------------------------------------------------

#! Project: Customizing middleware to accept custom headers

1) Refer djangomiddleware project
2) Create middleware folder in project directory
3) Inside it create __init__.py and middleware.py
4) Create a middleware named CheckBMPHeaderMiddleware
5) Add "djmiddleware.middleware.middleware.CheckBMPHeaderMiddleware" to INSTALLED_APPS in settings.py
6) Write a view and url pattern to test it.

------------------------------------------------------------------------------

#! Django User Authentication

#? Customizing the Django User Model

1) Refer djangoauthentication project
2) In models inherit the AbstractUser class from django.contrib.auth.models
3) In the new CustomUser model, add all the new required fields
4) Add "AUTH_USER_MODEL = "accounts.CustomUser"" to settings.py
5) Create a file named managers.py in the app directory and create a UserManager class inheriting from BaseUserManager
6) Add the CustomUser model to admin.py

-------------------------------------------------------------------------------

#! Django Advanced Stuff

#? Mastering Django Signals: A comprehensive guide

### Understanding Django Signals

- Signals are a way for different parts of a Django project to communicate
- Allow decoupled applications to react to events in other apps
- Follow a publisher-subscriber pattern

### Key Points

1. Signal Types
   - Model signals are of 4 types: pre_save, post_save, pre_delete, post_delete
   - Request/response signals

2. Signal Components
   - Sender: Object that emits the signal
   - Receiver: Function that responds to the signal

3. Signal Flow
   - Signal is sent by sender
   - Receivers execute in order they were connected

4. Connecting Signals
   - Using `@receiver` decorator
   - Manually connecting with `connect()` method

5. Signal Arguments
   - `sender`: The model class that triggered the signal
   - `instance`: The instance of the model
   - `**kwargs`: Additional keyword arguments

### Best Practices

- Use signals for decoupled communication between apps
- Keep signal handlers lightweight
- Order receivers carefully to avoid conflicts
- Consider using `weak=False` for long-lived receivers
- Use `sender` argument to ensure correct signal reception

#! Project: Automate Thumbnail Creation in Django using Signals

* Refer djangosignals/imageresizer project

1) In models.py, refer model named ImageModel
2) There are 4 signals: pre_save, post_save, pre_delete, post_delete
3) There are 2 components: sender and receiver
4) Register the models to admin and test it.

#? Mastering Email Sending in Django

We will implement a EMAIL based login system

#TODO => Refer => https://www.codingforentrepreneurs.com/blog/sending-email-in-django-from-gmail

1) Add this to settings.py
```
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = "s9xGQ@example.com"
EMAIL_HOST_PASSWORD = "password"
```

2) Create a file named emailer.py inside the app directory
```
from django.core.mail import send_mail
from django.conf import settings


def sendTestEmail(email, subject, message):
    send_mail(subject, message, settings.EMAIL_HOST_USER, [email])


def sendOtpToEmail(email, subject, message):
    # send_mail(subject, message, settings.EMAIL_HOST_USER, [email])
    print("EMAIL SENT")
```

3) Now refer views.py, urls.py and templates created.

#? Debug your Django App like a Pro with Django Debug Toolbar

#TODO => Follow the installation steps => https://django-debug-toolbar.readthedocs.io/en/latest/installation.html

### What is Django Debug Toolbar?

- A configurable set of panels that display various debug information about the current request/response
- Helps understand how your application functions and identifies problems
- Provides insights into database queries, templates, static files, etc.

### Key Features

1. Panels
   - SQL Queries
   - Settings
   - Templates
   - Cookies
   - Cache
   - Headers
   - Stats

2. Configuration
   - Customize which panels to display
   - Set panel order
   - Enable/disable panels

3. Integration
   - Works with Django's development server
   - Compatible with most web browsers

### Best Practices

- Use during development, not in production
- Customize panels based on your needs
- Familiarize yourself with all panels for effective debugging

#? Mastering Caching in Django: Boosting your apps performance

* For Windows Installation => https://github.com/tporadowski/redis/releases
* For Linux Installation => sudo apt-get install redis-server

#TODO => Refer => https://docs.djangoproject.com/en/5.1/topics/cache/

1) Add this to settings.py
```
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379",
    }
}
```

2) Run command => python3 manage.py createcachetable

3) Now refer fulltextsearch project's views

4) You can observe in the django-debug-toolbar that after using cache_page(60*5) decorator, it takes almost no time to render the page and the cache field is marked in django-debug-toolbar.

5) We also use cache.set and cache.get to cache data. This is done on individual fields rather than the whole page.

6) We can use cache.delete to delete the cache.

#? Rate Limiting in Django

1) Refer djangoauthentication project, we will implement rate limiting.

#? CRON Jobs in Django

Here are some brief but detailed notes on CRON jobs in Django:

### What are CRON Jobs?

- Scheduled tasks that run automatically at specified times
- Managed by cron daemon on Unix/Linux systems
- Useful for periodic maintenance, reporting, backups, etc.

### Django Crontab Package

- django-crontab is a popular package for implementing CRON jobs in Django
- Simplifies scheduling tasks within Django applications

### Key Features

1. Easy Scheduling
   - Define CRON expressions in Django settings
   - Run tasks at specific intervals

2. Task Execution
   - Execute Django management commands or custom functions
   - Can access Django environment and models

3. Management Commands
   - Leverage existing Django management commands
   - Create custom commands for CRON tasks

### Implementation Steps

1. Install django-crontab:
   ```
   pip install django-crontab
   ```

2. Add to INSTALLED_APPS:
   ```
   INSTALLED_APPS = [
       # ...
       'django_crontab',
   ]
   ```

3. Configure CRON jobs in settings.py:
   ```
   CRONJOBS = [
       ('*/5 * * * *', 'path.to.your.management.command_or_function'),
   ]
   ```

4. Apply CRON jobs:
   ```
   python manage.py crontab add
   ```

### Best Practices

- Use meaningful names for CRON job functions
- Implement proper error handling in CRON tasks
- Monitor CRON job logs for issues
- Consider using environment variables for sensitive data

### Example

```
# myapp/cron.py

def send_daily_summary():
    # Send daily summary email
    # ...

# settings.py
CRONJOBS = [
    ('0 0 * * *', 'myapp.cron.send_daily_summary'),
]
```

#? Logger in Django

Here are some brief but detailed notes on logging in Django:

### What is Logging in Django?

- Django provides a robust logging system for recording events in your application
- Helps diagnose issues, monitor application behavior, and track performance
- Integrates with Python's standard logging framework

### Key Components

1. Logger Objects
   - Represent a source of log messages
   - Named using dot notation (e.g., 'django.request')

2. Handlers
   - Determine what happens to log messages
   - Examples: Console, File, Email

3. Formatters
   - Control the format of log messages

4. Filters
   - Allow fine-tuning of which messages are logged

### Configuring Logging

- Main configuration done in LOGGING setting
- Uses dictConfig format
- Extends Django's default logging configuration

### Basic Logging Usage

```
import logging

logger = logging.getLogger(__name__)

logger.debug("Debug message")
logger.info("Info message")
logger.warning("Warning message")
logger.error("Error message")
logger.critical("Critical message")
```

### Best Practices

- Use appropriate log levels
- Avoid logging sensitive information
- Use structured logging for easier parsing
- Configure logging differently for development vs. production

### Example Configuration

```
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': '/path/to/django.log',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
        },
        'myapp': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
        },
    },
}
```

### Advanced Concepts

- Logger namespaces
- Propagation between loggers
- Custom filters and formatters
- Using environment variables for dynamic configuration

------------------------------------------------------------------------------------------------

#! Project: Web-Scraper to fetch IMDB Latest News

* Go to "https://www.imdb.com/news/movie/" as this is where we will be fetching data from.
* We will be using the combination of requests and BeautifulSoup to scrape the data from the website.

#! Integrating Elastic Search with Django

#? How to create and manage indexes in Elasticsearch

First we need to install elasticsearch to our linux system.
Refer => https://www.elastic.co/guide/en/elasticsearch/reference/current/deb.html

Step 1: wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
Step 2: sudo sh -c 'echo "deb https://artifacts.elastic.co/packages/7.x/apt stable main" > /etc/apt/sources.list.d/elastic-7.x.list'
Step 3: sudo apt-get update && sudo apt-get install elasticsearch
Step 4: sudo systemctl enable elasticsearch
Step 5: sudo systemctl start elasticsearch
Step 6: sudo systemctl status elasticsearch
Step 7: curl -X GET "localhost:9200/"
Output for above command:
```
{
  "name" : "your_node_name",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "some_uuid",
  "version" : {
    "number" : "7.x.x",
    "build_flavor" : "default",
    "build_type" : "deb",
    "build_hash" : "some_hash",
    "build_date" : "202x-xx-xxTxx:xx:xxZ",
    "lucene_version" : "8.x.x",
    "min_jvm_version" : "11",
    "max_jvm_version" : "16",
    "jvm" : {
      "version" : "some_version",
      "vm_name" : "OpenJDK",
      "vm_version" : "some_version"
    }
  }
}
```
Step 8: sudo nano /etc/elasticsearch/elasticsearch.yml and set all the security related settings to false.
Step 9: sudo systemctl restart elasticsearch
Step 10: curl -X GET "http://localhost:9200/"
```
{
  "name" : "pop-os",
  "cluster_name" : "elasticsearch",
  "cluster_uuid" : "0SYbnxUyS9StNHqJCPNn2g",
  "version" : {
    "number" : "8.17.1",
    "build_flavor" : "default",
    "build_type" : "deb",
    "build_hash" : "d4b391d925c31d262eb767b8b2db8f398103f909",
    "build_date" : "2025-01-10T10:08:26.972230187Z",
    "build_snapshot" : false,
    "lucene_version" : "9.12.0",
    "minimum_wire_compatibility_version" : "7.17.0",
    "minimum_index_compatibility_version" : "7.0.0"
  },
  "tagline" : "You Know, for Search"
}
```

#TODO => Refer => https://django-elasticsearch-dsl.readthedocs.io/en/latest/quickstart.html#install-and-configure

0) Create a seeder.py custom command which will seed the database with product and tag data from the dummyjson API and Faker if no data
1) pip install django-elasticsearch-dsl
2) Add "django_elasticsearch_dsl" to INSTALLED_APPS
3) Add the following to settings.py
```
ELASTICSEARCH_DSL={
    'default': {
        'hosts': 'http://localhost:9200',
    }
}
```
4) In the app, after defining models create documents.py

5) When we need to push data to elasticsearch server?
   a) Scenarios:
      1) When elasticsearch server is empty and we need to transfer data from database to elasticsearch
      2) When we need to update data in elasticsearch
      3) When we need to delete data from elasticsearch
      4) When there are changes in database and we need to update elasticsearch

6) python3 manage.py search_index 
```
(venv) ayush@pop-os:~/Desktop/Django-Advanced-Mastery/DJANGO_PROJECTS/4_elastic_search_project$ python3 manage.py search_index 
CommandError: No action specified. Must be one of '--create','--populate', '--delete' or '--rebuild' .
```
7) python3 manage.py search_index --rebuild
8) Now go to browser and type "localhost:9200/" and "http://localhost:9200/products/_search?q=*:*"
9) "http://localhost:9200/products/_search?q=dell"
```
{
  "took": 31,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total": {
      "value": 1,
      "relation": "eq"
    },
    "max_score": 4.83927,
    "hits": [
      {
        "_index": "products",
        "_id": "82",
        "_score": 4.83927,
        "_source": {
          "brand_name": {

          },
          "title": "New DELL XPS 13 9300 Laptop",
          "description": "The New DELL XPS 13 9300 Laptop is a compact and powerful device, featuring a virtually borderless InfinityEdge display and high-end performance for various tasks.",
          "category": "laptops",
          "price": 1499.99,
          "brand": "Dell",
          "sku": "XBJJ446X",
          "thumbnail": "https://cdn.dummyjson.com/products/images/laptops/New%20DELL%20XPS%2013%209300%20Laptop/thumbnail.png"
        }
      }
    ]
  }
}
```

* Download Multi Elasticsearch Heads Chrome Extension for extra details

#TODO => Refer => https://www.elastic.co/guide/en/elasticsearch/reference/current/term-level-queries.html

#! Project: Building an API to fetch data from elasticsearch

* Refer 4_elastic_search_project in the DJANGO_PROJECTS folder

#? Introduction to Celery

#! Getting Started with Celery: Background Tasks and Task Queues in Django

### What is Celery?

- Distributed task queue for Python
- Background Task Manager
- Allows running tasks asynchronously in the background
- Improves application responsiveness and scalability

### Key Components

1. Celery Worker
   - Executes tasks asynchronously
   - Runs as a separate process

2. Message Broker
   - Handles task distribution (e.g., RabbitMQ, Redis)

3. Celery Application
   - Configures connection to message broker
   - Defines tasks

### Setting Up Celery in Django

1. Install Celery:
   ```
   pip install celery[redis]
   ```

2. Create Celery app instance:
   ```
   from celery import Celery

   celery_app = Celery('your_project_name')
   celery_app.config_from_object('django.conf:settings', namespace='CELERY')
   celery_app.autodiscover_tasks()
   ```

3. Configure in settings.py:
   ```
   CELERY_BROKER_URL = 'redis://localhost:6379'
   CELERY_RESULT_BACKEND = 'redis://localhost:6379'
   ```

4. Create tasks.py in your app:
   ```
   @celery_app.task
   def my_background_task(arg1, arg2):
       # Task logic here
   ```

### Running Celery Workers

- Start worker:
  ```
  celery -A your_project_name worker --loglevel=info
  ```

### Best Practices

- Use async tasks for CPU-bound operations
- Handle exceptions in tasks
- Use task timeouts
- Monitor worker status

### Example: Sending Email in Background

```
from django.core.mail import send_mail
from celery_app.tasks import send_email_async

def register_user(request):
    # ... user creation logic ...
    send_email_async.delay(user.email, 'Welcome!')
    return redirect('success_page')
```

### Advantages

- Improved application responsiveness
- Better resource utilization
- Scalable task processing

#! Building a Task Scheduler in Celery

#TODO => Refer => https://docs.celeryq.dev/en/latest/django/first-steps-with-django.html

All the code snippets are from the above documentation link

1) pip install celery
2) In the project folder, create a celery.py file and add the following code:
```
import os

from celery import Celery

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'scraper.settings')

app = Celery('scraper')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()


@app.task(bind=True, ignore_result=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```
3) In the project's __init__.py file, add the following line:
```
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```
4) In the project's settings.py file, add the following line:
```
CELERY_BROKER_URL = 'redis://localhost:6379/0'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = 'UTC'
```
5) In the app folder, create a tasks.py file and add any example tasks:
```
from celery import shared_task
import time


@shared_task
def add(x, y):
    time.sleep(5)
    return x + y
```
6) To boot up your celery server, use command: celery -A scraper worker --loglevel=info
7) Create views using celery tasks and url patterns to test it

#! Monitoring Celery Tasks
1. For monitoring, we will use flower => pip install flower
2. Use "celery -A scraper flower"
3. Open http://localhost:5555 in your browser

4. We can also use django-celery-result => pip install django-celery-results
5. Add it to INSTALLED_APPS in settings.py => "django_celery_results"
6. Add the following code to settings.py
"
CELERY_RESULT_BACKEND = 'django-db'
"

#! Mastering Celery Beat: A Comprehensive Guide to Periodic Scheduling

Here are some brief but detailed notes on mastering Celery Beat for periodic scheduling:

### What is Celery Beat?

- Part of Celery ecosystem for scheduling tasks
- Allows running tasks at regular intervals or based on cron expressions
- Integrates with Django ORM for database-backed schedules

### Key Components

1. Schedules
   - IntervalSchedule: Defines fixed time intervals
   - CrontabSchedule: Uses cron-like syntax for complex timing

2. PeriodicTasks
   - Models representing scheduled tasks
   - Stored in the database

3. Celery Beat Service
   - Runs periodically to execute scheduled tasks

### Setting Up Celery Beat

1. Install django-celery-beat:
   ```
   pip install django-celery-beat
   ```

2. Add to INSTALLED_APPS:
   ```
   INSTALLED_APPS = [
       # ...
       'django_celery_beat',
   ]
   ```

3. Configure in settings.py:
   ```
   CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers.DatabaseScheduler'
   ```

### Creating Periodic Tasks

1. Create schedules:
   ```
   from django_celery_beat.models import IntervalSchedule, CrontabSchedule

   schedule, created = IntervalSchedule.objects.get_or_create(
       every=10,
       period=IntervalSchedule.MINUTES
   )
   ```

2. Create periodic tasks:
   ```
   from django_celery_beat.models import PeriodicTask

   PeriodicTask.objects.create(
       interval=schedule,
       name='My Task',
       task='myapp.tasks.my_task_function',
   )
   ```

### Best Practices

- Use meaningful names for tasks
- Handle exceptions in scheduled tasks
- Monitor Celery Beat logs
- Consider using environment variables for sensitive data

### Example Configuration

```
CELERY_BEAT_SCHEDULE = {
    'my-task': {
        'task': 'myapp.tasks.my_task_function',
        'schedule': 60.0,  # Run every minute
    },
}
```

### Advanced Concepts

- Task arguments and keyword arguments
- Expiration times for tasks
- Disabling/enabling tasks dynamically
- Using Django Admin interface for task management

#TODO => Refer => https://pypi.org/project/django-celery-beat/
#TODO => Refer => https://docs.celeryq.dev/en/latest/userguide/periodic-tasks.html
#TODO => Refer => https://django-celery-beat.readthedocs.io/en/latest/

1) pip install django-celery-beat
2) Add "django_celery_beat" to INSTALLED_APPS in settings.py
3) Migrate => python3 manage.py migrate django_celery_beat
4) Add the following code to settings.py
```
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'
```
5) You can just boot up the celery beat => celery -A [project-name] beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler

#! Approach 1 to create periodic task

a) Go to settings.py and add the following code:
```
CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'

CELERY_BEAT_SCHEDULE = {
    'add': {
        'task': 'home.tasks.add',
        'schedule': 60.0,  # Run every minute
        'args': (16, 16),
    },
}
```

#! Approach 2 to create periodic task
a) Go to tasks.py and add the following code:
```
@shared_task
def create_user_info():
    name = fake.name()
    email = fake.email()
    password = fake.password()
    age = random.randint(10, 30)  
    
    gender_choices = ['M', 'F', 'O', 'P']
    gender = random.choice(gender_choices)
    
    user_info = UserInfo.objects.create(name=name,email=email,password=password,age=age,gender=gender)
    
    return f"User Info created with ID: {user_info.id}"


# You can choose between a specific set of periods:
# IntervalSchedule.DAYS
# IntervalSchedule.HOURS
# IntervalSchedule.MINUTES
# IntervalSchedule.SECONDS
# IntervalSchedule.MICROSECONDS
schedule, created = IntervalSchedule.objects.get_or_create(
    every=1,
    period=IntervalSchedule.MINUTES
)

PeriodicTask.objects.update_or_create(
    interval = schedule,
    name = "Create UserInfo",
    task = "home.tasks.create_user_info",
)
```

6) Go to admin panel and check the periodic tasks there.

7) Final commands to run:
   * python3 manage.py runserver
   * celery -A scraper worker --loglevel=info
   * celery -A scraper beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler

#? Django with RabbitMQ

Ques) What is RabbitMQ?

Ans) RabbitMQ is an open-source message broker that implements the Advanced Message Queuing Protocol (AMQP). It is a popular choice for building distributed messaging systems and microservices.
It follows the principle of "publish-subscribe" where messages are published to a queue and consumed by one or more subscribers. "FIFO" mechanism is used to ensure that messages are processed in the order they are published.

1. RabbitMQ revolves around 2 things:
   * Producer - Publishes messages to a queue
   * Consumer - Consumes messages from a queue

2. In our project, we will use our django application as a producer. For this check producer.py file.

3. For consumer, it can be any other service which consumes the messages from the queue, like a microservice. It can be made using a FastAPI or any other framework. For now we will just create a consumer.py file and run it manually.
Type command: "python3 consumer.py" so that it will act as a consumer server and be up and running.

** Go to "https://www.cloudamqp.com/" and create a new RabbitMQ instance. Then go to overview and copy the URL string from the AMQP details section. Click on the "OVERVIEW" button to open the monitoring page where you can see the instance details and graphs.

#! Project: AUtomate Excel Creation in Django using RabbitMQ

* Refer 5_rabbitmq_project in the DJANGO_PROJECTS folder

Commands to run:
   * python3 manage.py runserver
   * python3 rabbitmq_consumer.py

----------------------------------------------------------------------

#? Load Testing in Django using Locust

#! Load Testing in Django using Locust

* Refer locustproject

Steps:
   * Setup your Django project and application
   * Create a custom seeder command and seed database using faker package
   * pip install locust
   * Create a locustfile.py file in the root of the project
   * To run locust: locust -f locustfile.py
   * In browser, go to "http://127.0.0.1:8089/" and set the required parameters and run the test.

** locustfile.py **
```
from locust import HttpUser, task , between
from faker import Faker
import random
fake = Faker()

class WebsiteUser(HttpUser):

    @task(5)
    def get_products(self):
        self.client.get('/api/products/')

    @task(3)
    def submit_feedback(self):
        payload = {
            "name" : fake.name(),
            "email" : fake.email(),
            "message" : fake.text()
        }
        self.client.post('/api/submit-feedback/', json=payload)

    @task(2)
    def get_details(self):
        product_id = random.randint(1, 500)
        self.client.get(f'/api/products/{product_id}/')
```

----------------------------------------------------------------------

#? Using Kafka in Django

#! What is Kafka and Zookeeper? A complete introduction

1) In Delivery services, we need to track the delivery of packages and the location of the vehicle. This is achieved using Kafka because Kafka is a real-time streaming platform which streams data in real-time.
2) Kafka is very powerful when compared to web-sockets as it can handle millions of requests per second and provide lots of features.
3) Kafka is a distributed event streaming platform used for building real-time data pipelines and streaming applications. Its designed to handle large volumes of data by enabling the efficient transmission of records (events, messages, logs, etc.) between systems.

Key features:
   * Scalable and fault-tolerant: Kafka is built to scale horizontally and handle large data loads with high availability.
   * Distributed: Kafka operates as a cluster of servers (brokers), storing streams of records across different partitions.
   * Real-time: It processes data in real time, making it ideal for applications requiring low-latency data ingestion and analysis (e.g., log aggregation, monitoring, event-driven architectures).
   * Publish/Subscribe model: Producers send data to topics, and consumers read from these topics.

Its widely used in areas like log aggregation, real-time analytics, and event-driven microservices.

4) Kafka has lots of things like:
   * topic - a collection of messages or data. They are identified by a category or feed name to which messages are published. Each topic contains a stream of records.
   * partition - a collection of messages within a topic from where we can pull data. A sub-division of a topic. Partitions allow Kafka to scale horizontally by distributing data across multiple brokers. Each partition is an ordered, immutable sequence of messages.
   * producer - a service which produces data. A client application that sends records (messages) to a Kafka topic.
   * consumer - a service which consumes data. A client application that reads records from a Kafka topic.
   * broker - a server inside cluster which stores data. A Kafka server (node) that stores data and serves consumers and producers. A Kafka cluster is made up of multiple brokers.
   * offset - a unique identifier for each partition. A unique identifier (number) for each record within a partition. It represents the position of a record in a partition.
   * replication - The process of duplicating data across multiple brokers to ensure fault tolerance. Each partition can have replicas stored on different brokers.
   * redention - The process of determining how long Kafka retains records in a topic. Records are retained for a specified time period or until the storage space limit is reached.
   * stream - A continuous flow of records in Kafka, often processed in real time using Kafka Streams (an API for stream processing).

5) Zookeeper is a distributed coordination service that Kafka uses to manage and maintain the distributed state of the Kafka cluster. 

It helped with tasks like:

   * Broker coordination: Zookeeper tracked which brokers were part of the Kafka cluster and which topics/partitions they were responsible for.
   * Leader election: Zookeeper helped elect a leader for each partition to ensure that there was a single source of truth for writing and reading data from that partition.
   * Cluster metadata management: It stored the metadata related to the Kafka brokers, topics, and partitions to help other brokers and consumers discover cluster information.
   * Fault tolerance: Zookeeper helped Kafka detect broker failures and take necessary actions like leader re-election for partitions.

In summary, Zookeeper was crucial for coordination in Kafka clusters.

For example, a group of clusters is made which is assigned to Zookeeper and the leader of the group is elected by Zookeeper. This leader is responsible for the coordination and management of the Kafka cluster.


----------------------------------------------------------------------To be continued----------------------------------------------------------------------

#? Dockerising Django Application

#! What is Docker and installing Docker

Here are some brief but detailed notes on Docker and installing Docker in Linux:

### What is Docker?

- Platform for developing, shipping, and running applications
- Uses containers for packaging applications and their dependencies
- Enables consistent development and deployment across different environments
- Provides isolation and portability for applications

### Key Components

1. Images
   - Blueprints for containers
   - Packaged software with all dependencies

2. Containers
   - Instances of images
   - Lightweight, portable units of software

3. Docker Engine
   - Core component of Docker
   - Manages building, running, and distributing Docker containers

4. Docker Hub
   - Public registry for sharing and discovering Docker images

Analogy => Ubuntu is a container and its .iso is an image

Steps:

1) Create a Dockerfile
   * This file defines the instructions for building the Docker image

2) Create a .dockerignore file
   * This file tells Docker which files and directories to ignore when building an image (similar to .gitignore).

3) Build the Docker image
   * Use the Docker CLI to build the image from the Dockerfile.
   * docker build -t my-django-app-image .
   
4) Create a docker-compose.yml file
   * This file helps you define and run multi-container Docker applications.

5) Start the application with Docker Compose
   * Run the containers defined in your docker-compose.yml file.
   * docker-compose up

6) Verify the application
   * Access the application at http://localhost:8000 or whichever port you specified in the Dockerfile

7) Stop and remove the containers
   * docker-compose down

8) Push the image to Docker Hub
   * docker tag your-image-name yourusername/your-image-name
   * docker push yourusername/your-image-name

#TODO => Installing Docker on Linux => Refer Docker Documentation and follow the instructions

#TODO => For indetail info on docker, refer my another repository based on Docker => https://github.com/Ayush29Ayush/Docker-Playground/tree/master

#! Dockerizing Django Application

1) Create Django Project and Application
2) Create Dockerfile
3) Create docker-compose.yml
4) Change DATABASES in settings.py according to your database in docker-compose.yml
5) Run docker-compose build
6) Run docker-compose up 
# docker-compose up --build (This usually corrupts the volume data) Avoid this
7) To hit migrations inside container: docker-compose exec web python manage.py migrate
8) ANOTHER WAY => To hit migrations inside container: docker exec -it aa5ec0ee1bd6 python manage.py migrate
9) To open shell inside container: docker-compose exec web python manage.py shell
10) To open bash inside container: docker-compose exec web bash or docker exec -it aa5ec0ee1bd6 bash
11) Run docker-compose down
12) To run container in detached mode: docker-compose up -d

BEST APPROACH:
   * docker-compose build
   * docker-compose up
   * docker ps
   * docker exec -it aa5ec0ee1bd6 bash or docker-compose exec web bash (which is better as it does not need id)
   * Then migrate, createsuperuser, shell or use any other command inside container as you do while local development
      * python manage.py migrate
      * python manage.py seeder
      * python manage.py createsuperuser


Terminal Output:
```
[ayush@pop-os:~/D/D/0/docker_project][09:50:15 PM IST][G:master=]
>$ docker-compose down --volumes --remove-orphans
Removing aa5ec0ee1bd6_docker_project_db_1 ... done
Removing network docker_project_default
Removing volume docker_project_docker_django_postgres_data
[ayush@pop-os:~/D/D/0/docker_project][09:50:24 PM IST][G:master=]
>$ docker-compose build
db uses an image, skipping
Building web
[+] Building 13.9s (11/11) FINISHED                                                                                                                                      docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                                                                     0.0s
 => => transferring dockerfile: 743B                                                                                                                                                     0.0s
 => [internal] load metadata for docker.io/library/python:3.10.12                                                                                                                        3.1s
 => [auth] library/python:pull token for registry-1.docker.io                                                                                                                            0.0s
 => [internal] load .dockerignore                                                                                                                                                        0.0s
 => => transferring context: 2B                                                                                                                                                          0.0s
 => [1/5] FROM docker.io/library/python:3.10.12@sha256:bac3a0e0d16125977e351c861e2f4b12ecafeaa6f72431dc970d0b9155103232                                                                  0.0s
 => => resolve docker.io/library/python:3.10.12@sha256:bac3a0e0d16125977e351c861e2f4b12ecafeaa6f72431dc970d0b9155103232                                                                  0.0s
 => [internal] load build context                                                                                                                                                        0.5s
 => => transferring context: 882.11kB                                                                                                                                                    0.3s
 => CACHED [2/5] WORKDIR /code                                                                                                                                                           0.0s
 => CACHED [3/5] COPY requirements.txt /code/                                                                                                                                            0.0s
 => CACHED [4/5] RUN pip install -r requirements.txt                                                                                                                                     0.0s
 => [5/5] COPY . /code/                                                                                                                                                                  2.8s
 => exporting to image                                                                                                                                                                   7.1s
 => => exporting layers                                                                                                                                                                  3.6s
 => => exporting manifest sha256:b7808a23fe901c4be451a0f6ac965d96350100e780d229129037b73f6ce019b8                                                                                        0.0s
 => => exporting config sha256:737500d54591fa659a1777e25ff1dc3ba821a9365601aac5f52b9f14bda27075                                                                                          0.0s
 => => exporting attestation manifest sha256:4ef9b22e720a3e60c6103e272ccac3df7d070d886a14444c690d006b0b784377                                                                            0.0s
 => => exporting manifest list sha256:c477f564a9d45780f7fd409597b2c9bb9be4a1f4f229cef3a56d67cce6f7cbab                                                                                   0.0s
 => => naming to docker.io/library/docker_project_web:latest                                                                                                                             0.0s
 => => unpacking to docker.io/library/docker_project_web:latest                                                                                                                          2.8s

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/tip3mxcllep5f3lqxs1rmxmv0
[ayush@pop-os:~/D/D/0/docker_project][09:52:47 PM IST][G:master=]
>$ docker-compose up
Creating network "docker_project_default" with the default driver
Creating volume "docker_project_docker_django_postgres_data" with default driver
Pulling db (postgres:13)...
13: Pulling from library/postgres
35199d0a6eca: Download complete
1539d6d4b0a0: Download complete
4db0bf51897c: Download complete
ef3e9a00774a: Download complete
23f17e809847: Download complete
b35f5f06ba1f: Download complete
090e86dd07d4: Download complete
349ff876226d: Download complete
b7830a5f7a9e: Download complete
ed61c92d86a2: Download complete
23644c5635ca: Download complete
0920e99e58fd: Download complete
c4489854ba43: Download complete
Digest: sha256:1b154a7bbf474aa1a2e67dc7c976835645fe6c3425320e7ad3f5a926d509e8fc
Status: Downloaded newer image for postgres:13
Creating docker_project_db_1 ... done
Creating docker_project_web_1 ... done
Attaching to docker_project_db_1, docker_project_web_1
```

Summary of Key Terms:
   * Dockerfile: A script used to build a Docker image.
   * Docker Image: A blueprint for creating containers, built using a Dockerfile.
   * Docker Container: A running instance of a Docker image.
   * docker-compose.yml: A configuration file used to define and run multi-container Docker applications with Docker Compose.

Simple flow:
   * Write a Dockerfile (build an image).
   * Run docker-compose.yml (manage containers with services).


------------------------------------------------------------------------------------------------------------------------------------

#? Introduction to Websockets and Django Channels

#! What is Websockets and Django Channels?

Here are some brief but detailed notes on WebSockets, Django Channels, and Daphne:

### WebSockets

- Full-duplex communication protocol
- Enables real-time bidirectional communication between client and server
- Used for applications requiring instant updates

Key characteristics:
- Real-time data exchange without polling
- Persistent connection throughout the session
- Low latency
- Bi-directional communication

### Django Channels

- Built-in framework for handling WebSockets in Django
- Integrates with Django's asynchronous support
- Allows building real-time features in Django apps

Components:
- Consumers: Handle WebSocket connections
- Routing: Manages dispatching of connections to consumers
- ASGI Application: Configures how different protocols are handled

### Daphne

- Official ASGI server maintained by Django project
- Handles both HTTP and WebSocket connections
- Used with Django Channels for real-time functionality

#TODO => This is the proper way to setup Django Channels and Daphne.

Official Documentation: https://channels.readthedocs.io/en/latest/#

Step 1: Install Required Dependencies
   * pip install channels
   * pip install daphne
   * pip install channels_redis

Step 2: Update Django Settings
   * Add "daphne" to INSTALLED_APPS in settings.py at the very beginning
   * Add "channels" to INSTALLED_APPS in settings.py

   * ASGI_APPLICATION = "your_project_name.asgi.application"

   * Add CHANNEL_LAYERS in settings.py
      "
      CHANNEL_LAYERS = {
         'default': {
            'BACKEND': 'channels_redis.core.RedisChannelLayer',
            'CONFIG': {
                  "hosts": [('127.0.0.1', 6379)],  # Replace with your Redis server
            },
         },
      }
      "

Step 3: ASGI Configuration
   * Create asgi.py in your project directory
      "
      import os
      from django.core.asgi import get_asgi_application
      from channels.routing import ProtocolTypeRouter, URLRouter
      from channels.auth import AuthMiddlewareStack

      os.environ.setdefault("DJANGO_SETTINGS_MODULE", "your_project_name.settings")

      application = ProtocolTypeRouter({
         "http": get_asgi_application(),
         "websocket": AuthMiddlewareStack(
            URLRouter(
                  # Add your WebSocket URL routing here
            )
         ),
      })
      "

Step 4: Create a Consumer for WebSocket Handling
   * Create consumer.py in your app directory
      "
      import json
      from channels.generic.websocket import AsyncWebsocketConsumer

      class ChatConsumer(AsyncWebsocketConsumer):
         async def connect(self):
            self.room_name = "chat_room"  # You can set this dynamically based on user or URL
            self.room_group_name = f"chat_{self.room_name}"

            # Join room group
            await self.channel_layer.group_add(
                  self.room_group_name,
                  self.channel_name
            )

            await self.accept()

         async def disconnect(self, close_code):
            # Leave room group
            await self.channel_layer.group_discard(
                  self.room_group_name,
                  self.channel_name
            )

         async def receive(self, text_data):
            text_data_json = json.loads(text_data)
            message = text_data_json["message"]

            # Send message to room group
            await self.channel_layer.group_send(
                  self.room_group_name,
                  {
                     "type": "chat_message",
                     "message": message
                  }
            )

         async def chat_message(self, event):
            message = event["message"]

            # Send message to WebSocket
            await self.send(text_data=json.dumps({
                  "message": message
            }))
      "

Step 5: Create a Routing Configuration
   * Create routing.py in your project directory
      "
      from django.urls import re_path
      from your_app_name.consumers import ChatConsumer

      websocket_urlpatterns = [
         re_path(r'ws/chat/$', ChatConsumer.as_asgi()),
      ]
      "

Step 6: Update asgi.py to include websocket routing
   * Update asgi.py to include websocket routing
      "
      from django.core.asgi import get_asgi_application
      from channels.routing import ProtocolTypeRouter, URLRouter
      from channels.auth import AuthMiddlewareStack
      from your_project_name.routing import websocket_urlpatterns  # Import the WebSocket routing

      os.environ.setdefault("DJANGO_SETTINGS_MODULE", "your_project_name.settings")

      application = ProtocolTypeRouter({
         "http": get_asgi_application(),
         "websocket": AuthMiddlewareStack(
            URLRouter(
                  websocket_urlpatterns  # Add the URL routing for WebSockets here
            )
         ),
      })
      "

Step 7: Add WebSocket Support to Your Frontend
   * sample script tag for frontend 
      "
      <script>
         const chatSocket = new WebSocket(
            'ws://' + window.location.host + '/ws/chat/'
         );

         chatSocket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            document.querySelector('#chat-log').value += (data.message + '\n');
         };

         chatSocket.onclose = function(e) {
            console.error('Chat socket closed unexpectedly');
         };

         document.querySelector('#chat-message-input').focus();
         document.querySelector('#chat-message-input').onkeyup = function(e) {
            if (e.keyCode === 13) {  // Enter key
               const messageInputDom = document.querySelector('#chat-message-input');
               const message = messageInputDom.value;
               chatSocket.send(JSON.stringify({
               'message': message
               }));
               messageInputDom.value = '';  // Clear the input
            }
         };
         </script>
      "

Step 8: Run the Server
   * Youll need to use Daphne to run the server instead of the default WSGI server. You can do so by running:
      * daphne your_project_name.asgi:application
      * daphne your_project_name.asgi:application -b 0.0.0.0 -p 8000

   * You can also use the Django development server to run the server, but it may be less efficient.
      * python3 manage.py runserver

Step 9: You can use POSTMAN to test the server:
   * ws://localhost:8000/ws/main/

#! Creating Consumers and setting websocket urls

#TODO => Refer => https://channels.readthedocs.io/en/latest/installation.html

* Refer "django_websocket_project"

------------------------------------------------------------------------------------------------------------------------------------

#? Django Project Deploymemt

#! Understanding Difference between Shared & VPS hosting

1) Shared Hosting
   * Shared hosting is a type of hosting service that allows multiple users to share a single server.
   * Mini partitions of the server are allocated to each user, and they share the same resources.
   * Not a dedicated server, but a shared server. Can be used for low-performance projects.
   * Not great for hosting as user cannot install software and packages on their own according to their requirements.
   * It has PHP and Apache based system.

2) VPS Hosting
   * VPS stands for "Virtual Private Server."
   * VPS hosting is a type of hosting service that allows a users to have their own dedicated server.
   * Users can install their own software and packages on their own according to their requirements.
   * Great for hosting high-performance projects.
   * For Django, we need to install Python, Django, Nginx, WhiteNoise, Gunicorn or Daphne and other packages as per our requirements.

#TODO => Deployment Reference => https://medium.com/@ganapriyakheersagar/hosting-django-application-with-nginx-and-gunicorn-in-production-99e64dc4345a

#! Understanding Gunicorn & Nginx

1) Gunicorn - It is a WSGI server used to run Django applications.
            - It will act as a middleware between Nginx and Django.

2) Nginx - It is a web server.
         - It also acts as a reverse proxy and load balancer for the Gunicorn server.
         - Serves Static and Media files.
         - Handles HTTP requests and forwards them to the Gunicorn server.
         - Handles SSL/TLS connections.
         - Caching
         - Load Balancing - It balances the load between multiple servers.

#! Deploying Entire Django Project on VPS using Github Nginx Gunicorn

1) Get VPS (Virtual Private Server):
   * AWS (Amazon Web Services) - EC2
   * Digital Ocean - Droplet
   * GCP (Google Cloud Platform) - Compute Engine
   * Azure (Microsoft Azure) - Virtual Machine
   * We can also host our own personal machine as VPS.

2) Lets use Digital Ocean, so create a Droplet with the following configuration:
   * Image: Ubuntu 20.04 LTS
   * Size: 2GB
   * Region: nyc1
   * SSH Keys: None
   * Password: Set your password

3) Push your project to Github: Use the Expense Tracker project as an example
   * git init
   * git add .
   * git commit -m "Initial commit"
   * git remote add origin https://github.com/<username>/<project-name>.git
   * git push -u origin master

4) Refer => https://www.digitalocean.com/community/tutorials/how-to-set-up-django-with-postgres-nginx-and-gunicorn-on-ubuntu

5) Copy the IP address of your created server and open your terminal from your project directory
   * Login to your server using SSH -> ssh root@<ip-address>
   * sudo apt update
   * sudo apt install python3-venv python3-dev libpq-dev postgresql postgresql-contrib nginx curl
   * sudo -u postgres psql
   * CREATE DATABASE myproject;
   * CREATE USER myprojectuser WITH PASSWORD 'password';
   * ALTER ROLE myprojectuser SET client_encoding TO 'utf8';
   * ALTER ROLE myprojectuser SET default_transaction_isolation TO 'read committed';
   * ALTER ROLE myprojectuser SET timezone TO 'UTC';
   * GRANT ALL PRIVILEGES ON DATABASE myproject TO myprojectuser;
   * \q
   * exit
   * mkdir ~/myprojectdir
   * cd ~/myprojectdir
   * python3 -m venv venv
   * source venv/bin/activate
   * git clone https://github.com/<username>/<project-name>.git
   * cd <project-name>
   * pip install --upgrade pip
   * pip install -r requirements.txt (Install gunicorn if not present in requirements.txt)
   * nano settings.py (make changes as per your requirements like database, serving static files using WhiteNoise, gunicorn, ALLOWED_HOSTS, etc.)
   
6) Check if project is able to run:
   * python manage.py migrate
   * python manage.py createsuperuser
   * python manage.py collectstatic 
   * sudo ufw allow 8000
   * python manage.py runserver 0.0.0.0:8000
   * Go to browser and type "localhost:8000/" and "http://server_domain_or_IP:8000/" and check if the project is running or not.
   * Go to admin page and login using the created credentials for superuser.

7) Testing Gunicorns Ability to Serve the Project
   * cd <project-name>
   * gunicorn --bind 0.0.0.0:8000 myproject.wsgi

   * if whitenoise is not installed:
      * Note: The admin interface will not have any of the styling applied since Gunicorn does not know how to find the static CSS content responsible for this.
   * if whitenoise is installed:
      * Note: The admin interface will have the styling applied since Gunicorn knows how to find the static CSS content responsible for this.

8) Creating systemd Socket and Service Files for Gunicorn

You have tested that Gunicorn can interact with our Django application, but you should now implement a more robust way of starting and stopping the application server. To accomplish this, youll make systemd service and socket files.

The Gunicorn socket will be created at boot and will listen for connections. When a connection occurs, systemd will automatically start the Gunicorn process to handle the connection.

Start by creating and opening a systemd socket file for Gunicorn with sudo privileges:
   * sudo nano /etc/systemd/system/gunicorn.socket
   * Add the following content:
   ```
   [Unit]
   Description=gunicorn socket

   [Socket]
   ListenStream=/run/gunicorn.sock

   [Install]
   WantedBy=sockets.target
   ```
   * Save and close the file.

9) Create a systemd service file for Gunicorn with sudo privileges:
   * sudo nano /etc/systemd/system/gunicorn.service
   * Add the following content (make changes as per your requirements and path):
   ```
   [Unit]
   Description=gunicorn daemon
   Requires=gunicorn.socket
   After=network.target

   [Service]
   User=sammy
   Group=www-data
   WorkingDirectory=/home/sammy/myprojectdir
   ExecStart=/home/sammy/myprojectdir/myprojectenv/bin/gunicorn \
            --access-logfile - \
            --workers 3 \
            --bind unix:/run/gunicorn.sock \
            myproject.wsgi:application

   [Install]
   WantedBy=multi-user.target
   ```

10) Run the following commands:
   * sudo systemctl start gunicorn.socket
   * sudo systemctl enable gunicorn.service
   * sudo systemctl status gunicorn.socket
   * sudo systemctl status gunicorn.service
   * sudo systemctl status gunicorn

11) Check for existence of gunicrn.sock file in /run directory:
   * file /run/gunicorn.sock
   * If file does not exist, check the gunicorn socket's log by typing:
      * sudo journalctl -u gunicorn.socket

12) If everything goes well and there are no errors:
   * sudo systemctl daemon-reload
   * sudo systemctl restart gunicorn
   * sudo systemctl status gunicorn

13) NGINX Setup:
   * Refer => https://github.com/Ayush29Ayush/Full-NGINX-Tutorial
   * Refer => https://www.digitalocean.com/community/tutorials/how-to-set-up-django-with-postgres-nginx-and-gunicorn-on-ubuntu
   * Now go to browser and type "http://server_domain_or_IP:8000/" and check if the project is running or not.

14) Domain Setup:
   * We will buy a domain name and point it to our server.
   * There are various ways to do this, one of them is to use the Hostinger domain service.
   * Now after buying a domain, we have to change the NAME SERVER of the domain to the IP address of our server. Get them from the DNS records section of digitalocean and then go to "DNS/Nameservers" section of Hostinger and select "Change nameserver" and paste the IP address of our server.
   * In the "Networking" section of digitalocean, add your domain name.
   * In digitalocean's DNS records, map your domain name to the IP address of your server and press "Create new record".

   * Now again login to your server and update the NGINX configuration file with the new domain name.
      * sudo nano /etc/nginx/sites-available/myproject
      * server_name 146.190.103.144 myproject.com www.myproject.com;
      * sudo ln -s /etc/nginx/sites-available/myproject /etc/nginx/sites-enabled
      * sudo nginx -t
      * sudo systemctl restart nginx
      * sudo ufw allow 'Nginx Full'
      * sudo ufw status

   * Go to "https://dnschecker.org/" and type your domain name and check if it is working or not.

   * Go to browser and type your domain name and check if it is working or not.

15) For SSL Setup:
   * Refer => https://github.com/Ayush29Ayush/Full-NGINX-Tutorial
   * Refer => https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-22-04

   * Go to browser and type your domain name and check if the warning is showing or not.

------------------------------------------------------------------------------------------------------------------------------------

DOUBTS

Ques) For my django project in production, in the server gunicorn is used as my WSGI server and NGINX and web server and to serve static files. So do I need whitenoise? Also if I use whitenoise to serve static files then do i need to serve them in nginx also?

Ans)

In your production setup, you're using Gunicorn as your WSGI server and NGINX to serve static files. If you're already serving static files through NGINX, you generally don't need Whitenoise. Here's a breakdown of the components and how they interact:

NGINX Serving Static Files
   NGINX is an efficient static file server, and it can handle the delivery of static files like images, JavaScript, and CSS directly to users, without involving your Django application. This is a very common setup in production because NGINX can serve these files quickly and with minimal overhead.

Whitenoise
   Whitenoise is a library that allows your Django application to serve static files directly, even in production, without needing a separate web server like NGINX for that purpose. It's useful for smaller setups or simpler applications where you don't want to configure an additional web server for static files. It can serve files in a way that ensures they're properly cached and compressed.

Do You Need Whitenoise?
   If you're using NGINX to serve static files, you dont need Whitenoise. NGINX is more than capable of handling the static file delivery.
   If you want Whitenoise, it's typically used for serving static files when you want to keep everything within the Django stack (for example, if you don't want to manage an additional server or if you're using platforms like Heroku). But with NGINX already set up for this purpose, its redundant.
If You Use Whitenoise, Do You Need NGINX?
   If you switch to using Whitenoise to serve static files, you don't need NGINX to serve static files anymore. Whitenoise would handle it within the Django application itself. However, NGINX would still be useful for handling other things like reverse proxying requests to Gunicorn and serving media files (like user uploads), but static file serving can be handled by Whitenoise in this case.

Summary:
   If NGINX is already serving your static files efficiently, you dont need Whitenoise.
   If you decide to use Whitenoise, NGINX can still serve other things (like media files or reverse proxying requests) but would no longer be needed for static files.


------------------------------------------------------------------------------------------------------------------------------------

#! NOTES

1) For production (Best Practices):
   * WSGI server: Gunicorn
   * ASGI server: Daphne
   * Django Channels (works with ASGI architecture): Daphne
   * Serve static files: nginx or WhiteNoise
   * Use Redis for caching: Redis
   * Background Tasks: Celery
   * Message Broker: Redis or RabbitMQ or Kafka
   * Use Docker to build images: Dockerfile and docker-compose.yml (Refer => https://github.com/Ayush29Ayush/Docker-Playground)
   * Deployment: Nginx (Reverse Proxy) (Refer => https://github.com/Ayush29Ayush/Full-NGINX-Tutorial)

   * For traditional WSGI: We create views and urls
   * For ASGI based WebSockets: We create consumers and routing

------------------------------------------------------------------------------------------------------------------------------------