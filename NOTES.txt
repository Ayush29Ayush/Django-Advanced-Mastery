#! Become 2% of THE Django Developer
We will learn the most advanced topics of Backend development. Write Powerful Scalable code with proper test cases latest tech stack like Redis, Elastic Search, Kibana, Celery, Sockets etc.

#? Python 

1. Python is a high level programming language
2. Used in various applications like web development, Data Science, Machine Learning, AI, IoT, Game Development, Business Applications, etc.
3. Some companies that use python include Google, Amazon, Facebook, Netflix, Uber, etc.

#? Python Installation

1. For Windows: Download Python from https://www.python.org/downloads/ and keep all the default options along with Add to Path.
2. For Linux: sudo apt install python3
3. For MacOS: brew install python

#? Python2 vs Python3
1. Python2 is the legacy version of Python and Python3 is the latest version of Python.
2. Performance: Python3 is faster than Python2.
3. Backward compatibility: Python3 is backward compatible with Python2.
4. Libraries: Python3 has more libraries than Python2.

#? Python Operators
1. Arithmetic Operators: +, -, *, /, %, //, **
2. Assignment Operators: =, +=, -=, *=, /=, %=
3. Comparison Operators: ==, !=, >, <, >=, <=
4. Logical Operators: and, or, not
5. Identity Operators: is, is not
6. Membership Operators: in, not in
7. Bitwise Operators: &, |, ^, ~, <<, >>
8. Special Operators: lambda, yield

#? Python Conditions
1. if, elif, else
2. nested if
3. multiple conditions with and, or, not

#? Python Loops
1. for loop
2. while loop
3. break statement
4. continue statement
5. pass statement
6. Combination of break and continue statements

#? Python Data Structures
1. Lists - mutable ordered collection of elements
    * Attributes: len(), index()
    * Operations: append(), remove(), sort()
2. 2D Lists - lists containing other lists
    * Attributes: len() (for rows), len(matrix1) (for columns)
    * Operations: indexing, slicing, modifying elements
3. Dictionaries - key-value pairs
    * Attributes: keys(), values(), items()
    * Operations: add key-value pair, remove key
4. Tuples - immutable ordered collection of elements
    * Attributes: count(), index()
    * Operations: concatenation
5. Sets - unordered collection of unique elements
    * Operations: add(), remove(), check membership
6. Strings - sequence of characters
    * Operations: upper(), lower(), count(), startswith(), endswith(), replace()

#? Python Functions
1. Functions - basic function definition and call
2. Lambda functions - concise anonymous functions
3. Recursive functions - functions calling themselves
4. Default arguments - providing default values for function parameters
5. Keyword arguments - passing arguments by name
6. args and kwargs - handling variable number of positional and keyword arguments
7. Scope in Python - global variables, local variables, and modifying variables in enclosing scopes

#? Advanced Python - Object Oriented Programming
1. Classes and Objects - defining classes and creating instances
2. Class Attributes, Methods and variables - using class-level attributes and methods
3. Constructors - initializing objects with init method
4. Constructor Overloading - simulating constructor overloading (Python doesn't support true overloading)
5. Inheritance and Polymorphism - creating base and derived classes, demonstrating polymorphic behavior
6. Abstraction and Encapsulation - hiding internal details and protecting data
7. Static Methods and Class Methods - using @staticmethod and @classmethod decorators

#? Advanced Python - Threads
1. The problem that threads solve - concurrent execution of tasks which helps a program to perform multiple operations simultaneously rather than sequentially one after the other.
2. Creating threads with run(), start(), and join() methods.
3. Passing arguments to threads using lambda functions.
4. The difference between threads and processes (using multiprocessing).
5. The difference between run() and start() methods of threads. 
6. Creating threads using custom classes.
7. Create and solve real world example of downloading multiple images using threads -> Refer 09-python-threads-image-downloader.py

Key Differences between run(), start() and join() Methods:

a) Execution Context:
    * start() initiates the thread's execution.
    * run() defines what the thread does.
    * join() waits for the thread to finish.
b) Timing:
    * start() is typically called first, followed by join().    
    * run() is called automatically by start().
c) Blocking Nature:
    * start() is non-blocking.
    * join() is blocking, waiting for the thread to complete.
d) Return Value:
    * start() returns None.
    * run() doesn't return anything directly; its contents determine the output.
    * join() always returns None 3.

In summary, start() initiates the thread, run() defines its behavior, and join() ensures the main program waits for the thread to complete before continuing. Understanding these methods is crucial for proper thread management in Python.

* threading.current_thread().name is used to get the name of the current thread.
* threading.enumerate() returns a list of all currently active running threads.
* threading.get_ident() returns the unique identifier id of the current thread.

----------------------------------------------------------------------------------------------------------------------------------------

Here's a concise point and subpoint-wise answer combining the information from both answers:

#! What is Django?

- High-level Python web framework
- Often called "batteries included" due to comprehensive features
- Enables rapid development of secure and maintainable websites

#! Benefits of Django

1. Rapid Development
   - Follows MTV (Model-Template-View) architecture
   - Rich set of built-in features reduces third-party package needs

2. Security
   - Built-in security features (CSRF protection, clickjacking protection, XSS attack prevention)
   - Regular updates patch vulnerabilities promptly

3. Scalability
   - Designed to handle high traffic and large datasets efficiently
   - Supports asynchronous processing for long-running tasks

4. Extensive Libraries and Tools
   - Powerful ORM (Object-Relational Mapping) system
   - Flexible authentication and authorization system
   - Robust admin interface out of the box

5. Community and Ecosystem
   - Large and active community
   - Extensive documentation and tutorials available

6. Flexibility
   - Suitable for both small and large-scale applications
   - Modular architecture allows customization

7. Testing Framework
   - Built-in testing tools (unittest, test cases)

8. Internationalization (i18n) and Localization (l10n)
   - Built-in support for internationalizing projects

9. Database Agnostic
   - Supports multiple database backends out of the box

#! Why Prefer Django?

1. "Batteries Included"
   - Many built-in features save development time
   - Ready-to-use components reduce boilerplate code

2. Security Out of the Box
   - Reduces risk of common web vulnerabilities

3. Large Community and Ecosystem
   - Easy to find solutions or hire developers familiar with Django
   - Extensive third-party packages available

4. Scalability and Performance
   - Designed for high traffic and large datasets
   - Supports asynchronous processing

5. Rapid Prototyping
   - Allows quick development of prototypes and MVPs

6. Learning Curve
   - Steep initially, but efficient once mastered

7. Cross-platform Compatibility
   - Runs on Windows, macOS, and Linux

8. Extensibility
   - Custom apps and middleware extend functionality

9. ORM (Object-Relational Mapping)
   - High-level interface for database queries

10. Admin Interface
    - Powerful admin interface saves significant development time

11. Testing Framework
    - Built-in testing tools ensure code quality

12. Modular Architecture
    - Allows building complex applications with reusable components

13. Multiple Database Support
    - Connects to different types of databases simultaneously

14. Caching with Redis
    - Built-in cache framework supports Redis backend

15. RabbitMQ Integration
    - Supports AMQP protocol, compatible with RabbitMQ

16. Load Testing with Locust
    - Can be integrated for load testing

17. Testing with Pytest
    - Works well with pytest for unit and integration testing

18. Django REST Framework (DRF)
    - Built on top of Django, focuses on API development

19. Admin Panel
    - Powerful admin interface for managing data models

20. ORM
    - Abstracts database operations for database-independent code

21. Docker and Deployment with Nginx
    - Can be containerized using Docker
    - Works well with Nginx as reverse proxy and load balancer

22. Celery
    - Built-in task queueing system for asynchronous processing

23. Not Good for Simpler Projects
    - Better suited for complex features rather than simple projects

24. Steep Learning Curve
    - Requires knowledge of entire structure before starting

This concise overview covers the key points about Django, its benefits, and why it's preferred, while also mentioning some potential drawbacks.

#? Building your first django project and application:

1. Create a virtual environment using command: python3 -m venv venv
2. Activate the virtual environment: source venv/bin/activate
3. Install django: pip install django
4. Create a new project: django-admin startproject myfirstproject .
5. Create a new application: python manage.py startapp myfirstapp
6. Run the development server: python manage.py runserver
7. To run the development server in debug mode: python manage.py runserver --debug
8. To run the development server in debug mode with an IP address and port: python manage.py runserver --debug 0.0.0.0:8000
9. To create a superuser account: python manage.py createsuperuser
10. Store requirements in requirements.txt: pip freeze > requirements.txt

#? Django project and application files to know about:

1. settings.py: Configuration for the Django project.
2. urls.py: URL patterns for the Django project.
3. wsgi.py: WSGI server configuration for the Django project.
4. asgi.py: ASGI server configuration for the Django project.
5. manage.py: Command-line utility for managing the Django project.
6. models.py: Database models for the Django project.
7. forms.py: Form definitions for the Django project.
8. views.py: View functions for the Django project.
9. templates: HTML templates for the Django project.
10. static: Static files for the Django project.
11. migrations: Database migrations for the Django project.
12. tests: Unit and integration tests for the Django project.
13. admin.py: Admin interface for the Django project.
14. .env : Environment variables for the Django project.

#? Breaking Down Django Apps: What They are and How They Work:

1. We breakdown an project to various little apps each with a specific task.
2. Example: A Library Management system can have several apps like:
    * Books App
    * Authors App
    * Publishers App
    * Orders App
    * Members App
    * Borrowing App
    * Admin App, etc.

3. Each app has its own models, views, templates, and URLs.
4. Each app has its own database and can be accessed from the main project.
5. Each app has its own URL patterns and can be accessed from the main project.
6. Each app has its own templates and can be accessed from the main project.
7. Each app has its own static files and can be accessed from the main project.
8. Each app has its own migrations and can be accessed from the main project.
9. Each app has its own tests and can be accessed from the main project.

Here are some key differences and comparisons between WSGI and ASGI:

#? Key Points Comparing WSGI and ASGI

1. Purpose:
   - WSGI: Primarily for web servers
   - ASGI: For asynchronous application servers

2. Asynchronous Support:
   - WSGI: Synchronous only
   - ASGI: Supports both synchronous and asynchronous applications

3. Protocol:
   - WSGI: Uses a synchronous request-response model
   - ASGI: Uses an asynchronous event loop model

4. Framework Support:
   - WSGI: Supported by most traditional web frameworks (Django, Flask)
   - ASGI: Supported by newer asynchronous frameworks (FastAPI, Django Asynchronous)

5. Performance:
   - WSGI: Better suited for I/O-bound applications
   - ASGI: More efficient for CPU-bound tasks and real-time applications

6. Compatibility:
   - WSGI: Widely supported across various web servers
   - ASGI: Less widespread but growing in adoption

7. Use Cases:
   - WSGI: Ideal for traditional web applications
   - ASGI: Better suited for real-time applications (chat apps, gaming platforms)

8. Implementation:
   - WSGI: Simpler implementation due to synchronous nature
   - ASGI: More complex implementation due to asynchronous nature

9. Future-Proofing:
   - WSGI: May become outdated as more applications require real-time features
   - ASGI: Better positioned for future web application needs

10. Learning Curve:
    - WSGI: Easier to learn and implement
    - ASGI: Steeper learning curve due to asynchronous concepts

In summary, while WSGI remains relevant for traditional web applications, ASGI is becoming increasingly important for modern, high-performance web applications that require real-time features and efficient handling of concurrent requests.

Here are some key points comparing Daphne and Gunicorn:

#? Daphne vs Gunicorn

1. Purpose:
   - Daphne: ASGI server primarily for running Django Channels
   - Gunicorn: WSGI server for running traditional Django applications

2. Protocol Support:
   - Daphne: Supports HTTP/1.1, HTTP/2, and WebSockets
   - Gunicorn: Supports WSGI (not ASGI)

3. Use Cases:
   - Daphne: Ideal for real-time applications and WebSocket-based projects
   - Gunicorn: Better for traditional web applications with synchronous requests

4. Performance:
   - Daphne: Optimized for real-time and WebSocket applications
   - Gunicorn: Generally faster for standard WSGI applications

5. Integration:
   - Daphne: Designed to work with Django Channels
   - Gunicorn: Works with standard Django projects

6. Configuration:
   - Daphne: Simpler configuration focused on ASGI support
   - Gunicorn: More flexible configuration options for WSGI servers

7. Learning Curve:
   - Daphne: Steeper learning curve due to real-time features
   - Gunicorn: Easier to learn and use for traditional web apps

8. Compatibility:
   - Daphne: Primarily used with Django Channels
   - Gunicorn: Compatible with various Python web frameworks

9. Scalability:
   - Daphne: Good for scaling real-time applications
   - Gunicorn: Well-suited for scaling traditional web applications

10. Market Position:
    - Daphne: Growing in popularity for real-time Django applications
    - Gunicorn: Established as a standard WSGI server for Django projects

In summary, Daphne is specialized for real-time applications and WebSocket support, while Gunicorn remains a versatile choice for traditional Django web applications. The choice between them depends on the specific requirements of your project, particularly whether real-time features are needed.

#! Understanding URL's and Views

#? Understanding URL's and Views in Django
1. Views are the python functions or classes that handle HTTP requests and return HTTP responses.
2. URLs map HTTP requests to views.
3. URLs are defined in the application's urls.py file which are then used in the project's urls.py file.
4. URLs can be defined using regular expressions or string patterns.
5. Views are defined in the application's views.py file.
6. Views are responsible for performing logic like rendering templates, processing forms, returning JSON responses, etc.
7. Views are associated with URLs using URL patterns.

#? Building Dynamic URL Patterns in Django
Example of building a dynamic URL pattern: 
   * http://domain.com/contact/<int:contact_id> where contact_id is an dynamic integer parameter according to which lets say tables will be plotted and data will be fetched

#TODO Approach - 1:

* Define a URL pattern with a dynamic parameter. 
** urls.py **
"
path('dynamic_route/<int:number>', dynamic_route, name='dynamic_route'),
"
** views.py **
"
def dynamic_route(request, number):
    for i in range(0,10):
        print(f"{number} * {i+1} = ", (i+1)*number)
    return HttpResponse(f"Hello, the number is {number}")
"

#TODO Approach - 2:

* Define a URL pattern with a dynamic parameter using a regular expression which will use re_path rather than path
Here's a simple example of defining a URL pattern with a dynamic parameter using a regular expression in Django:
** urls.py **

```
from django.urls import re_path
from . import views

urlpatterns = [
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
]
```

Key points:
1. We use `re_path()` to allow regular expressions in our URL pattern.
2. The regular expression `r'^articles/(?P<year>[0-9]{4})/$'` captures:
   - `^articles/` matches the start of the URL path
   - `(?P<year>[0-9]{4})` captures exactly 4 digits as the year
   - `$` ensures the URL ends exactly there
3. The captured group `<year>` will be passed as an argument to the view function.
4. This pattern will match URLs like `/articles/2025/`.
5. The corresponding view function would look something like:

```
def year_archive(request, year):
      # Handle requests for articles from the specified year
      return HttpResponse(f"Articles from {year}")
```

#! Templates and Static Files

#? How to render HTML Templates and use context in Django
1. Define a template in the templates directory.
2. Create a context dictionary to pass data to the template in your view.
3. Render the template using the context dictionary.
4. Have a url pattern that maps to your view.

** sample code for view **
```
from django.shortcuts import render

def index(request):
    # Define context dictionary
    context = {
        'title': 'Welcome to My Site',
        'message': 'This is the home page',
        'current_year': 2023,
    }
    
    # Render template with context
    return render(request, 'index.html', context)
```
** sample code for templates **
```
<h1>{{ title }}</h1>
<p>{{ message }}</p>
<p>Current year: {{ current_year }}</p>
```

#? Understanding Django Templates in Detail
1. Templates are HTML files that contain placeholders for dynamic content.
2. Context is used to pass data to the template.
3. Some of the most used Django template tags include:
a) {% for %} and {% endfor %} for loops
b) {% if %} and {% else %} for conditional statements
c) {% extends %} to inherit from a parent template
d) {% block %} and {% endblock %} to define a block of content that can be overridden in child templates
e) {% with %} to create a temporary context
f) {% url %} to generate URLs
g) {% include %} to include another template
h) {{ | }} is pipe operator used to manipulate data, for example {{ user.first_name|upper }} or {{ users|length }} where users will be a list of users
i) {% load static %} to load and serve static files
j) {% load i18n %} to load translation files
k) {% load crispy_forms_tags %} to load crispy forms tags
l) {% csrf_token %} to generate a CSRF token for forms protection
m) {% now %} to get the current date and time
n) {% comment %} and {% endcomment %} to add comments in the template

For more, refer => "https://docs.djangoproject.com/en/5.1/ref/templates/builtins/"
You can also create your own custom template tags, refer => "https://docs.djangoproject.com/en/5.1/howto/custom-template-tags/"

#! Database Setup in Django

Django has support for several popular databases, including:
a) MySQl
b) PostgreSQL
c) SQLite

1. For now we will be using PostgreSQL, I am using Linux so we need to install PostgreSQL, its dependecies and pgAdmin
a) For PostgreSQL: "https://www.postgresql.org/download/linux/ubuntu/" and follow the steps under "To manually configure the Apt repository, follow these steps"
b) For pgAdmin: "https://www.pgadmin.org/download/pgadmin-4-apt/" and follow the steps under "To use this repository, run the following commands"

#TODO - Installation Guide for PostgreSQL and pgAdmin => "https://www.youtube.com/watch?v=UGfteFq_6Co"

2. Now we will setup our database with our Django project but before that, create a database and set that in NAME variable under DATABASES in settings.py
a) For SQLite:
```
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
```
b) For PostgreSQL: Download PostgreSQL Client using command "pip install psycopg2-binary"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '5432',
    }
}
```
c) For MySQL: Download MySQL Client using command "pip install mysqlclient"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '3306',
    }
}
```

3. Now we will run Django command "python3 manage.py migrate" to migrate our database.

#! Django Models

Here's a more detailed version of the notes on Django models, incorporating the additional information from the search results:

#? Defining Models and Fields

1. Model Definition:
   - Create a class that inherits from `models.Model`
   - Define fields as attributes of the model class
   - Use `Meta` inner class for metadata about the model

2. Common Fields:
   - CharField: For short text strings
   - TextField: For longer text content
   - IntegerField: For whole numbers
   - FloatField: For decimal numbers
   - DateField: For dates
   - BooleanField: For true/false values
   - ForeignKey: For relationships with other models
   - ManyToManyField: For many-to-many relationships
   - ImageField: For image uploads
   - FileField: For file uploads
   - EmailField: For email addresses
   - SlugField: For URL-friendly strings
   - DurationField: For durations
   - IPAddressField: For IP addresses
   - GenericIPAddressField: For both IPv4 and IPv6 addresses
   - PositiveIntegerField: For positive integers
   - PositiveSmallIntegerField: For small positive integers
   - PositiveFloatField: For positive floating-point numbers
   - DateTimeField: For dates and times
   - TimeField: For times
   - UUIDField: For universally unique identifiers
   - XMLField: For storing XML data
   - JSONField: For storing JSON data
   - BitField: For storing single boolean values in a compact way
   - AutoField: Automatically increments for each new record
   - BigAutoField: Similar to AutoField but uses a larger range
   - SmallIntegerField: For small integers
   - FilePathField: For file paths
   - RelatedManager: For managing related objects

** sample code for models.py **
```
from django.db import models


class College(models.Model):
    college_name = models.CharField(max_length=100)
    college_address = models.CharField(max_length=100)


class Student(models.Model):
    gender_choices = (("Male", "Male"), ("Female", "Female"))
    college = models.ForeignKey(
        College, on_delete=models.CASCADE, null=True, blank=True
    )
    name = models.CharField(max_length=100)
    mobile_number = models.CharField(max_length=12)
    email = models.EmailField()
    gender = models.CharField(max_length=10, choices=gender_choices, default="Male")
    student_bio = models.TextField()
    date_of_birth = models.DateField()
    student_profile_image = models.ImageField(
        null=True, blank=True, upload_to="student_profile_images/"
    )
    student_file = models.FileField(null=True, blank=True, upload_to="student_files/")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

#? Model Relationships

1. One-to-One Relationships:
   - Use `OneToOneField` to establish a one-to-one relationship
   - Useful for extending existing models without duplicating fields

2. One-to-Many Relationships:
   - Use `ForeignKey` field in one model to reference another model
   - Can specify `on_delete` parameter to handle cascading deletes

3. Many-to-Many Relationships:
   - Use `ManyToManyField` to establish many-to-many relationships
   - Can specify intermediate tables for complex relationships

4. Reverse Relationships:
   - Access related objects using `model_name_set` attribute
   - Use `ForeignKey.related_model` to get the related model class

* refer myfirstapp/firstmodels.py for more details

#? ORM (Object-Relational Mapping)

1. Definition:
   - Abstraction layer between Python code and database
   - Allows working with data as objects rather than writing SQL queries

2. Benefits:
   - Simplifies database operations
   - Provides a consistent interface across different databases
   - Reduces boilerplate code
   - Improves security by reducing direct SQL injection risks

3. Key Features:
   - Automatic creation of database schema from models
   - QuerySet API for filtering, sorting, and manipulating data
   - Support for complex queries using Django's ORM syntax
   - Raw SQL queries for performance-critical operations

4. QuerySet:
   - Lazy evaluation of database queries
   - Supports chaining of methods for complex queries using Q objects
   - Methods like `filter()`, `exclude()`, `order_by()`, etc.

5. Model Managers:
   - Custom managers can be defined to modify or extend QuerySet behavior
   - Useful for adding custom methods to model instances

6. Abstract Models:
   - Define a base class for models with shared fields
   - Inherit from `AbstractBaseUser` for custom user models

7. Model Methods:
   - Define methods within the model class for business logic
   - Useful for complex validations or calculations

8. Model Fields:
   - Use `choices` parameter for field values with predefined options
   - Implement custom validation using `clean()` method

9. Model Meta Options:
   - Specify database table name and app label
   - Set default values for fields
   - Configure index settings for fields

10. Model Signals:
    - Connect to signals like `pre_save`, `post_save`, etc., for model events
    - Useful for triggering actions before or after model changes


* After "python3 manage.py makemigrations" run "python3 manage.py migrate", open shell using "python3 manage.py shell" and insert few dummy data in database