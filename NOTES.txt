#! Become 2% of THE Django Developer
We will learn the most advanced topics of Backend development. Write Powerful Scalable code with proper test cases latest tech stack like Redis, Elastic Search, Kibana, Celery, Sockets etc.

#? Python 

1. Python is a high level programming language
2. Used in various applications like web development, Data Science, Machine Learning, AI, IoT, Game Development, Business Applications, etc.
3. Some companies that use python include Google, Amazon, Facebook, Netflix, Uber, etc.

#? Python Installation

1. For Windows: Download Python from https://www.python.org/downloads/ and keep all the default options along with Add to Path.
2. For Linux: sudo apt install python3
3. For MacOS: brew install python

#? Python2 vs Python3
1. Python2 is the legacy version of Python and Python3 is the latest version of Python.
2. Performance: Python3 is faster than Python2.
3. Backward compatibility: Python3 is backward compatible with Python2.
4. Libraries: Python3 has more libraries than Python2.

#? Python Operators
1. Arithmetic Operators: +, -, *, /, %, //, **
2. Assignment Operators: =, +=, -=, *=, /=, %=
3. Comparison Operators: ==, !=, >, <, >=, <=
4. Logical Operators: and, or, not
5. Identity Operators: is, is not
6. Membership Operators: in, not in
7. Bitwise Operators: &, |, ^, ~, <<, >>
8. Special Operators: lambda, yield

#? Python Conditions
1. if, elif, else
2. nested if
3. multiple conditions with and, or, not

#? Python Loops
1. for loop
2. while loop
3. break statement
4. continue statement
5. pass statement
6. Combination of break and continue statements

#? Python Data Structures
1. Lists - mutable ordered collection of elements
    * Attributes: len(), index()
    * Operations: append(), remove(), sort()
2. 2D Lists - lists containing other lists
    * Attributes: len() (for rows), len(matrix1) (for columns)
    * Operations: indexing, slicing, modifying elements
3. Dictionaries - key-value pairs
    * Attributes: keys(), values(), items()
    * Operations: add key-value pair, remove key
4. Tuples - immutable ordered collection of elements
    * Attributes: count(), index()
    * Operations: concatenation
5. Sets - unordered collection of unique elements
    * Operations: add(), remove(), check membership
6. Strings - sequence of characters
    * Operations: upper(), lower(), count(), startswith(), endswith(), replace()

#? Python Functions
1. Functions - basic function definition and call
2. Lambda functions - concise anonymous functions
3. Recursive functions - functions calling themselves
4. Default arguments - providing default values for function parameters
5. Keyword arguments - passing arguments by name
6. args and kwargs - handling variable number of positional and keyword arguments
7. Scope in Python - global variables, local variables, and modifying variables in enclosing scopes

#? Advanced Python - Object Oriented Programming
1. Classes and Objects - defining classes and creating instances
2. Class Attributes, Methods and variables - using class-level attributes and methods
3. Constructors - initializing objects with init method
4. Constructor Overloading - simulating constructor overloading (Python doesn't support true overloading)
5. Inheritance and Polymorphism - creating base and derived classes, demonstrating polymorphic behavior
6. Abstraction and Encapsulation - hiding internal details and protecting data
7. Static Methods and Class Methods - using @staticmethod and @classmethod decorators

#? Advanced Python - Threads
1. The problem that threads solve - concurrent execution of tasks which helps a program to perform multiple operations simultaneously rather than sequentially one after the other.
2. Creating threads with run(), start(), and join() methods.
3. Passing arguments to threads using lambda functions.
4. The difference between threads and processes (using multiprocessing).
5. The difference between run() and start() methods of threads. 
6. Creating threads using custom classes.
7. Create and solve real world example of downloading multiple images using threads -> Refer 09-python-threads-image-downloader.py

Key Differences between run(), start() and join() Methods:

a) Execution Context:
    * start() initiates the thread's execution.
    * run() defines what the thread does.
    * join() waits for the thread to finish.
b) Timing:
    * start() is typically called first, followed by join().    
    * run() is called automatically by start().
c) Blocking Nature:
    * start() is non-blocking.
    * join() is blocking, waiting for the thread to complete.
d) Return Value:
    * start() returns None.
    * run() doesn't return anything directly; its contents determine the output.
    * join() always returns None 3.

In summary, start() initiates the thread, run() defines its behavior, and join() ensures the main program waits for the thread to complete before continuing. Understanding these methods is crucial for proper thread management in Python.

* threading.current_thread().name is used to get the name of the current thread.
* threading.enumerate() returns a list of all currently active running threads.
* threading.get_ident() returns the unique identifier id of the current thread.

----------------------------------------------------------------------------------------------------------------------------------------

Here's a concise point and subpoint-wise answer combining the information from both answers:

#! What is Django?

- High-level Python web framework
- Often called "batteries included" due to comprehensive features
- Enables rapid development of secure and maintainable websites

#! Benefits of Django

1. Rapid Development
   - Follows MTV (Model-Template-View) architecture
   - Rich set of built-in features reduces third-party package needs

2. Security
   - Built-in security features (CSRF protection, clickjacking protection, XSS attack prevention)
   - Regular updates patch vulnerabilities promptly

3. Scalability
   - Designed to handle high traffic and large datasets efficiently
   - Supports asynchronous processing for long-running tasks

4. Extensive Libraries and Tools
   - Powerful ORM (Object-Relational Mapping) system
   - Flexible authentication and authorization system
   - Robust admin interface out of the box

5. Community and Ecosystem
   - Large and active community
   - Extensive documentation and tutorials available

6. Flexibility
   - Suitable for both small and large-scale applications
   - Modular architecture allows customization

7. Testing Framework
   - Built-in testing tools (unittest, test cases)

8. Internationalization (i18n) and Localization (l10n)
   - Built-in support for internationalizing projects

9. Database Agnostic
   - Supports multiple database backends out of the box

#! Why Prefer Django?

1. "Batteries Included"
   - Many built-in features save development time
   - Ready-to-use components reduce boilerplate code

2. Security Out of the Box
   - Reduces risk of common web vulnerabilities

3. Large Community and Ecosystem
   - Easy to find solutions or hire developers familiar with Django
   - Extensive third-party packages available

4. Scalability and Performance
   - Designed for high traffic and large datasets
   - Supports asynchronous processing

5. Rapid Prototyping
   - Allows quick development of prototypes and MVPs

6. Learning Curve
   - Steep initially, but efficient once mastered

7. Cross-platform Compatibility
   - Runs on Windows, macOS, and Linux

8. Extensibility
   - Custom apps and middleware extend functionality

9. ORM (Object-Relational Mapping)
   - High-level interface for database queries

10. Admin Interface
    - Powerful admin interface saves significant development time

11. Testing Framework
    - Built-in testing tools ensure code quality

12. Modular Architecture
    - Allows building complex applications with reusable components

13. Multiple Database Support
    - Connects to different types of databases simultaneously

14. Caching with Redis
    - Built-in cache framework supports Redis backend

15. RabbitMQ Integration
    - Supports AMQP protocol, compatible with RabbitMQ

16. Load Testing with Locust
    - Can be integrated for load testing

17. Testing with Pytest
    - Works well with pytest for unit and integration testing

18. Django REST Framework (DRF)
    - Built on top of Django, focuses on API development

19. Admin Panel
    - Powerful admin interface for managing data models

20. ORM
    - Abstracts database operations for database-independent code

21. Docker and Deployment with Nginx
    - Can be containerized using Docker
    - Works well with Nginx as reverse proxy and load balancer

22. Celery
    - Built-in task queueing system for asynchronous processing

23. Not Good for Simpler Projects
    - Better suited for complex features rather than simple projects

24. Steep Learning Curve
    - Requires knowledge of entire structure before starting

This concise overview covers the key points about Django, its benefits, and why it's preferred, while also mentioning some potential drawbacks.

#? Building your first django project and application:

1. Create a virtual environment using command: python3 -m venv venv
2. Activate the virtual environment: source venv/bin/activate
3. Install django: pip install django
4. Create a new project: django-admin startproject myfirstproject .
5. Create a new application: python manage.py startapp myfirstapp
6. Run the development server: python manage.py runserver
7. To run the development server in debug mode: python manage.py runserver --debug
8. To run the development server in debug mode with an IP address and port: python manage.py runserver --debug 0.0.0.0:8000
9. To create a superuser account: python manage.py createsuperuser
10. Store requirements in requirements.txt: pip freeze > requirements.txt

#? Django project and application files to know about:

1. settings.py: Configuration for the Django project.
2. urls.py: URL patterns for the Django project.
3. wsgi.py: WSGI server configuration for the Django project.
4. asgi.py: ASGI server configuration for the Django project.
5. manage.py: Command-line utility for managing the Django project.
6. models.py: Database models for the Django project.
7. forms.py: Form definitions for the Django project.
8. views.py: View functions for the Django project.
9. templates: HTML templates for the Django project.
10. static: Static files for the Django project.
11. migrations: Database migrations for the Django project.
12. tests: Unit and integration tests for the Django project.
13. admin.py: Admin interface for the Django project.
14. .env : Environment variables for the Django project.

#? Breaking Down Django Apps: What They are and How They Work:

1. We breakdown an project to various little apps each with a specific task.
2. Example: A Library Management system can have several apps like:
    * Books App
    * Authors App
    * Publishers App
    * Orders App
    * Members App
    * Borrowing App
    * Admin App, etc.

3. Each app has its own models, views, templates, and URLs.
4. Each app has its own database and can be accessed from the main project.
5. Each app has its own URL patterns and can be accessed from the main project.
6. Each app has its own templates and can be accessed from the main project.
7. Each app has its own static files and can be accessed from the main project.
8. Each app has its own migrations and can be accessed from the main project.
9. Each app has its own tests and can be accessed from the main project.

Here are some key differences and comparisons between WSGI and ASGI:

#? Key Points Comparing WSGI and ASGI

1. Purpose:
   - WSGI: Primarily for web servers
   - ASGI: For asynchronous application servers

2. Asynchronous Support:
   - WSGI: Synchronous only
   - ASGI: Supports both synchronous and asynchronous applications

3. Protocol:
   - WSGI: Uses a synchronous request-response model
   - ASGI: Uses an asynchronous event loop model

4. Framework Support:
   - WSGI: Supported by most traditional web frameworks (Django, Flask)
   - ASGI: Supported by newer asynchronous frameworks (FastAPI, Django Asynchronous)

5. Performance:
   - WSGI: Better suited for I/O-bound applications
   - ASGI: More efficient for CPU-bound tasks and real-time applications

6. Compatibility:
   - WSGI: Widely supported across various web servers
   - ASGI: Less widespread but growing in adoption

7. Use Cases:
   - WSGI: Ideal for traditional web applications
   - ASGI: Better suited for real-time applications (chat apps, gaming platforms)

8. Implementation:
   - WSGI: Simpler implementation due to synchronous nature
   - ASGI: More complex implementation due to asynchronous nature

9. Future-Proofing:
   - WSGI: May become outdated as more applications require real-time features
   - ASGI: Better positioned for future web application needs

10. Learning Curve:
    - WSGI: Easier to learn and implement
    - ASGI: Steeper learning curve due to asynchronous concepts

In summary, while WSGI remains relevant for traditional web applications, ASGI is becoming increasingly important for modern, high-performance web applications that require real-time features and efficient handling of concurrent requests.

Here are some key points comparing Daphne and Gunicorn:

#? Daphne vs Gunicorn

1. Purpose:
   - Daphne: ASGI server primarily for running Django Channels
   - Gunicorn: WSGI server for running traditional Django applications

2. Protocol Support:
   - Daphne: Supports HTTP/1.1, HTTP/2, and WebSockets
   - Gunicorn: Supports WSGI (not ASGI)

3. Use Cases:
   - Daphne: Ideal for real-time applications and WebSocket-based projects
   - Gunicorn: Better for traditional web applications with synchronous requests

4. Performance:
   - Daphne: Optimized for real-time and WebSocket applications
   - Gunicorn: Generally faster for standard WSGI applications

5. Integration:
   - Daphne: Designed to work with Django Channels
   - Gunicorn: Works with standard Django projects

6. Configuration:
   - Daphne: Simpler configuration focused on ASGI support
   - Gunicorn: More flexible configuration options for WSGI servers

7. Learning Curve:
   - Daphne: Steeper learning curve due to real-time features
   - Gunicorn: Easier to learn and use for traditional web apps

8. Compatibility:
   - Daphne: Primarily used with Django Channels
   - Gunicorn: Compatible with various Python web frameworks

9. Scalability:
   - Daphne: Good for scaling real-time applications
   - Gunicorn: Well-suited for scaling traditional web applications

10. Market Position:
    - Daphne: Growing in popularity for real-time Django applications
    - Gunicorn: Established as a standard WSGI server for Django projects

In summary, Daphne is specialized for real-time applications and WebSocket support, while Gunicorn remains a versatile choice for traditional Django web applications. The choice between them depends on the specific requirements of your project, particularly whether real-time features are needed.

#! Understanding URL's and Views

#? Understanding URL's and Views in Django
1. Views are the python functions or classes that handle HTTP requests and return HTTP responses.
2. URLs map HTTP requests to views.
3. URLs are defined in the application's urls.py file which are then used in the project's urls.py file.
4. URLs can be defined using regular expressions or string patterns.
5. Views are defined in the application's views.py file.
6. Views are responsible for performing logic like rendering templates, processing forms, returning JSON responses, etc.
7. Views are associated with URLs using URL patterns.

#? Building Dynamic URL Patterns in Django
Example of building a dynamic URL pattern: 
   * http://domain.com/contact/<int:contact_id> where contact_id is an dynamic integer parameter according to which lets say tables will be plotted and data will be fetched

#TODO Approach - 1:

* Define a URL pattern with a dynamic parameter. 
** urls.py **
"
path('dynamic_route/<int:number>', dynamic_route, name='dynamic_route'),
"
** views.py **
"
def dynamic_route(request, number):
    for i in range(0,10):
        print(f"{number} * {i+1} = ", (i+1)*number)
    return HttpResponse(f"Hello, the number is {number}")
"

#TODO Approach - 2:

* Define a URL pattern with a dynamic parameter using a regular expression which will use re_path rather than path
Here's a simple example of defining a URL pattern with a dynamic parameter using a regular expression in Django:
** urls.py **

```
from django.urls import re_path
from . import views

urlpatterns = [
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
]
```

Key points:
1. We use `re_path()` to allow regular expressions in our URL pattern.
2. The regular expression `r'^articles/(?P<year>[0-9]{4})/$'` captures:
   - `^articles/` matches the start of the URL path
   - `(?P<year>[0-9]{4})` captures exactly 4 digits as the year
   - `$` ensures the URL ends exactly there
3. The captured group `<year>` will be passed as an argument to the view function.
4. This pattern will match URLs like `/articles/2025/`.
5. The corresponding view function would look something like:

```
def year_archive(request, year):
      # Handle requests for articles from the specified year
      return HttpResponse(f"Articles from {year}")
```

#! Templates and Static Files

#? How to render HTML Templates and use context in Django
1. Define a template in the templates directory.
2. Create a context dictionary to pass data to the template in your view.
3. Render the template using the context dictionary.
4. Have a url pattern that maps to your view.

** sample code for view **
```
from django.shortcuts import render

def index(request):
    # Define context dictionary
    context = {
        'title': 'Welcome to My Site',
        'message': 'This is the home page',
        'current_year': 2023,
    }
    
    # Render template with context
    return render(request, 'index.html', context)
```
** sample code for templates **
```
<h1>{{ title }}</h1>
<p>{{ message }}</p>
<p>Current year: {{ current_year }}</p>
```

#? Understanding Django Templates in Detail
1. Templates are HTML files that contain placeholders for dynamic content.
2. Context is used to pass data to the template.
3. Some of the most used Django template tags include:
a) {% for %} and {% endfor %} for loops
b) {% if %} and {% else %} for conditional statements
c) {% extends %} to inherit from a parent template
d) {% block %} and {% endblock %} to define a block of content that can be overridden in child templates
e) {% with %} to create a temporary context
f) {% url %} to generate URLs
g) {% include %} to include another template
h) {{ | }} is pipe operator used to manipulate data, for example {{ user.first_name|upper }} or {{ users|length }} where users will be a list of users
i) {% load static %} to load and serve static files
j) {% load i18n %} to load translation files
k) {% load crispy_forms_tags %} to load crispy forms tags
l) {% csrf_token %} to generate a CSRF token for forms protection
m) {% now %} to get the current date and time
n) {% comment %} and {% endcomment %} to add comments in the template

For more, refer => "https://docs.djangoproject.com/en/5.1/ref/templates/builtins/"
You can also create your own custom template tags, refer => "https://docs.djangoproject.com/en/5.1/howto/custom-template-tags/"

#! Database Setup in Django

Django has support for several popular databases, including:
a) MySQl
b) PostgreSQL
c) SQLite

1. For now we will be using PostgreSQL, I am using Linux so we need to install PostgreSQL, its dependecies and pgAdmin
a) For PostgreSQL: "https://www.postgresql.org/download/linux/ubuntu/" and follow the steps under "To manually configure the Apt repository, follow these steps"
b) For pgAdmin: "https://www.pgadmin.org/download/pgadmin-4-apt/" and follow the steps under "To use this repository, run the following commands"

#TODO - Installation Guide for PostgreSQL and pgAdmin => "https://www.youtube.com/watch?v=UGfteFq_6Co"

2. Now we will setup our database with our Django project but before that, create a database and set that in NAME variable under DATABASES in settings.py
a) For SQLite:
```
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}
```
b) For PostgreSQL: Download PostgreSQL Client using command "pip install psycopg2-binary"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '5432',
    }
}
```
c) For MySQL: Download MySQL Client using command "pip install mysqlclient"
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost', 
        'PORT': '3306',
    }
}
```

3. Now we will run Django command "python3 manage.py migrate" to migrate our database.

#! Django Models

Here's a more detailed version of the notes on Django models, incorporating the additional information from the search results:

#? Defining Models and Fields

1. Model Definition:
   - Create a class that inherits from `models.Model`
   - Define fields as attributes of the model class
   - Use `Meta` inner class for metadata about the model

2. Common Fields:
   - CharField: For short text strings
   - TextField: For longer text content
   - IntegerField: For whole numbers
   - FloatField: For decimal numbers
   - DateField: For dates
   - BooleanField: For true/false values
   - ForeignKey: For relationships with other models
   - ManyToManyField: For many-to-many relationships
   - ImageField: For image uploads
   - FileField: For file uploads
   - EmailField: For email addresses
   - SlugField: For URL-friendly strings
   - DurationField: For durations
   - IPAddressField: For IP addresses
   - GenericIPAddressField: For both IPv4 and IPv6 addresses
   - PositiveIntegerField: For positive integers
   - PositiveSmallIntegerField: For small positive integers
   - PositiveFloatField: For positive floating-point numbers
   - DateTimeField: For dates and times
   - TimeField: For times
   - UUIDField: For universally unique identifiers
   - XMLField: For storing XML data
   - JSONField: For storing JSON data
   - BitField: For storing single boolean values in a compact way
   - AutoField: Automatically increments for each new record
   - BigAutoField: Similar to AutoField but uses a larger range
   - SmallIntegerField: For small integers
   - FilePathField: For file paths
   - RelatedManager: For managing related objects

** sample code for models.py **
```
from django.db import models


class College(models.Model):
    college_name = models.CharField(max_length=100)
    college_address = models.CharField(max_length=100)


class Student(models.Model):
    gender_choices = (("Male", "Male"), ("Female", "Female"))
    college = models.ForeignKey(
        College, on_delete=models.CASCADE, null=True, blank=True
    )
    name = models.CharField(max_length=100)
    mobile_number = models.CharField(max_length=12)
    email = models.EmailField()
    gender = models.CharField(max_length=10, choices=gender_choices, default="Male")
    student_bio = models.TextField()
    date_of_birth = models.DateField()
    student_profile_image = models.ImageField(
        null=True, blank=True, upload_to="student_profile_images/"
    )
    student_file = models.FileField(null=True, blank=True, upload_to="student_files/")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

#? Model Relationships

1. One-to-One Relationships:
   - Use `OneToOneField` to establish a one-to-one relationship
   - Useful for extending existing models without duplicating fields

2. One-to-Many Relationships:
   - Use `ForeignKey` field in one model to reference another model
   - Can specify `on_delete` parameter to handle cascading deletes

3. Many-to-Many Relationships:
   - Use `ManyToManyField` to establish many-to-many relationships
   - Can specify intermediate tables for complex relationships

4. Reverse Relationships:
   - Access related objects using `model_name_set` attribute
   - Use `ForeignKey.related_model` to get the related model class

* refer myfirstapp/firstmodels.py for more details

#? ORM (Object-Relational Mapping)

1. Definition:
   - Abstraction layer between Python code and database
   - Allows working with data as objects rather than writing SQL queries

2. Benefits:
   - Simplifies database operations
   - Provides a consistent interface across different databases
   - Reduces boilerplate code
   - Improves security by reducing direct SQL injection risks

3. Key Features:
   - Automatic creation of database schema from models
   - QuerySet API for filtering, sorting, and manipulating data
   - Support for complex queries using Django's ORM syntax
   - Raw SQL queries for performance-critical operations

4. QuerySet:
   - Lazy evaluation of database queries
   - Supports chaining of methods for complex queries using Q objects
   - Methods like `filter()`, `exclude()`, `order_by()`, etc.

5. Model Managers:
   - Custom managers can be defined to modify or extend QuerySet behavior
   - Useful for adding custom methods to model instances

6. Abstract Models:
   - Define a base class for models with shared fields
   - Inherit from `AbstractBaseUser` for custom user models

7. Model Methods:
   - Define methods within the model class for business logic
   - Useful for complex validations or calculations

8. Model Fields:
   - Use `choices` parameter for field values with predefined options
   - Implement custom validation using `clean()` method

9. Model Meta Options:
   - Specify database table name and app label
   - Set default values for fields
   - Configure index settings for fields

10. Model Signals:
    - Connect to signals like `pre_save`, `post_save`, etc., for model events
    - Useful for triggering actions before or after model changes


* After "python3 manage.py makemigrations" run "python3 manage.py migrate", open shell using "python3 manage.py shell" and insert few dummy data in database

#! Building Forms in Django

Django forms has various limitations and in actual project we prefer HTML forms over django forms. For pretty django forms we should use third party packages like "django-crispy-forms". 

#? Beginner's Guide to Django Forms

1. Introduction to Forms:
   - Forms are used to collect user input
   - They consist of fields and widgets
   - Django provides built-in form classes and widgets

2. Creating a Simple Form:
   - Import necessary modules
   - Define form fields
   - Create a form instance

3. Rendering Forms:
   - Use `as_p()` method to render form as paragraphs
   - Use `as_table()` method to render form as table
   - Use `as_ul()` method to render form as unordered list

4. Handling Form Data:
   - Access form data using `form.cleaned_data`
   - Use `is_valid()` method to check if form is valid

5. Customizing Forms:
   - Add custom validation
   - Set initial values
   - Make fields required

6. Form Fields:
   - CharField: For text input
   - IntegerField: For integer input
   - ChoiceField: For select dropdowns
   - DateTimeField: For date/time inputs
   - FileField: For file uploads

7. Form Widgets:
   - Textarea for multi-line text
   - CheckboxSelectMultiple for multiple selections
   - SelectDateWidget for date selection

8. Form Validation:
   - Built-in validation methods
   - Custom validation using `clean()` method

9. Form Security:
   - Use CSRF protection
   - Prevent cross-site scripting (XSS)

10. Form Types:
   - ModelForm for working with models
   - Form for custom forms

#? HTML Forms in Django

1. Basic Structure:
```
<form action="{% url 'view_name' %}" method="post">
      {% csrf_token %}
      {{ form.as_p }}
      <input type="submit" value="Submit">
</form>
```

2. Form Actions:
   - Use `{% url %}` tag to generate URLs
   - Specify `method` attribute (GET or POST)

3. Form Fields:
   - Text inputs: `<input type="text" name="field_name">`
   - Checkboxes: `<input type="checkbox" name="field_name">`
   - Radio buttons: `<input type="radio" name="field_name">`

4. File Uploads:
```
<form enctype="multipart/form-data">
      {{ form.as_p }}
</form>
```

5. Form Styling:
   - Use CSS classes for styling
   - Customize widget appearance

6. Form Submission:
   - Handle form submission in views
   - Process and validate form data

7. Error Handling:
   - Display validation errors
   - Show custom error messages

8. Form Libraries:
   - jQuery Form Plugin for AJAX submissions
   - Bootstrap Forms for responsive designs

Summary:
a) Make forms.py and use either DjangoForm or ModelForm
b) In template use form.as_p() to render form as paragraph and use csrf token
c) In view, use form.cleaned_data to access form data and is_valid() to check if form is valid
d) In view, use form.save() to save form data to database if the form is valid which will raise exception if form is invalid
e) If not using django forms and directly using HTML forms, get all the data from the request.POST and save it to the database using Model_name.objects.create()

#! Django Models Level 2 (Advanced)

#TODO Create vs Save vs Get_Or_Create method in Django (Interview Question)

Here are the key points comparing Create, Save, and Get_or_Create methods in Django:

#? Create Method

1. Usage:
   - `Model.objects.create(**kwargs)`
   - Creates a new object and saves it to the database in one step

2. Advantages:
   - More concise and readable for simple object creation
   - Automatically handles saving the new object

3. Behavior:
   - Always performs an INSERT operation
   - Returns the newly created object instance

4. Use cases:
   - Handling form submissions
   - Data imports where data is ready to save immediately

#?  Save Method

1. Usage:
   - `object.save()`
   - Saves an existing object instance to the database

2. Advantages:
   - Used when you already have an object instance
   - Allows for custom logic before saving

3. Behavior:
   - Performs either INSERT (new object) or UPDATE (existing object)
   - Requires manual object instantiation

4. Use cases:
   - Modifying existing objects instance
   - Custom validation before saving

#? Get_or_Create Method

1. Usage:
   - `Model.objects.get_or_create(**kwargs)`
   - Attempts to retrieve an object matching the kwargs, creating it if not found

2. Advantages:
   - Combines retrieval and creation in one step
   - Useful for ensuring object existence before use

3. Behavior:
   - First tries to get an existing object
   - If not found, creates and saves a new object

4. Use cases:
   - Ensuring object exists before use (e.g., in views)
   - Optimizing database queries

Key differences:
- Create always creates new objects
- Save works on existing objects instance or new ones
- Get_or_Create retrieves if possible, else creates

Choose based on your specific use case and object lifecycle requirements.

#TODO Use Faker for Inserting Dummy Data into your Django Models

1. pip install faker
2. Create a seed_db.py file and write code to insert dummy data into your models
#! Approach 1
3. Open shell and run dbSeeder() after importing it
#! Approach 2
4. Create a new file in your app's management/commands directory named "seeder.py"
5. Then use command "python manage.py seeder --number=20"
6. See your custom made commands by using "python3 manage.py"

#TODO Master Django ORM Lookups: Advanced Query Techniques and Searching

### 1. Chaining Queries

- Allows building complex queries step-by-step
- Enables highly specific queries while maintaining readability
- Examples:
  - Combining filters and ordering
  - Chaining aggregations
```
users = User.objects.filter(is_active=True).exclude(email__endswith='.com').order_by('-date_joined')
```

### 2. F() Expressions

- Allow performing database operations using values from the database
- Useful for maintaining data integrity and efficient updates
- Examples:
  - Increasing a value
  - Calculating discounts
```
User.objects.filter(age=F('current_age') + 1)
```

### 3. Q() Objects

- Enable building complex queries with logical OR and AND operators
- Useful for combining conditions dynamically
- Examples:
  - Constructing complex queries
  - Dynamic search
```
q1 = Q(first_name__startswith='J')
q2 = Q(last_name__endswith='sen')
result = User.objects.filter(q1 | q2)
```

### 4. Raw SQL Queries

- Allow executing raw SQL queries when needed
- Use `raw()` method for safe execution
- Examples:
  - Retrieving data
  - Updating data
  - Mapping results to model objects
```
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("SELECT username, email FROM auth_user WHERE age > 30")
    users = [User(username=row[0], email=row[1]) for row in cursor.fetchall()]
```

### 5. Advanced Query Techniques

- Using `annotate()` with expressions
- Combining multiple lookups
- Using `values()` and `values_list()`
- Creating custom managers
```
from django.db.models import F, ExpressionWrapper, DecimalField

User.objects.update(age=ExpressionWrapper(F('age') + 1, output_field=DecimalField()))
```

### 6. Searching Techniques

- Full-text searching
- Complex search queries using Q() objects
- Search with pagination
```
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank

results = Post.objects.annotate(
    search_vector=SearchVector('title', 'content')
).filter(search_vector=SearchQuery('Django tutorial')).order_by('-search_rank')
```

### 7. Performance Optimization

- Using select_related() and prefetch_related()
- Avoiding n+1 query problem
- Caching strategies
```
posts = Post.objects.select_related('category').prefetch_related('tags')
```

### 8. Working with Dates and Times

- Date range queries
- Calculating time differences
- Formatting dates/times
```
from django.utils.timezone import now

recent_posts = Post.objects.filter(created_at__range=(now() - timedelta(days=7), now()))
```

These points cover various advanced techniques in Django ORM, from complex querying methods to performance optimization and specific use cases like full-text searching and working with dates.

#TODO Aggregate and Annotations in Django

Here are brief but detailed notes on Aggregate and Annotations in Django, organized with points and subpoints:

#? Aggregate

1. Definition:
   - Performs aggregation operations on QuerySets
   - Returns a dictionary with aggregated results

2. Usage:
   - Used with `aggregate()` method
   - Typically used for summary statistics

3. Examples:
   - Count: `Count('id')`
   - Sum: `Sum('price')`
   - Avg: `Avg('price')`
   - Min: `Min('price')`
   - Max: `Max('price')`

4. Key characteristics:
   - Collapses entire QuerySet into a single value
   - Cannot be chained with other QuerySet methods
   - Useful for getting overall statistics

5. Syntax:
```
result = Model.objects.aggregate(Sum('field'))
```

#? Annotation

1. Definition:
   - Adds computed fields to QuerySet results
   - Returns a new QuerySet with annotated fields

2. Usage:
   - Used with `annotate()` method
   - Can be chained with other QuerySet methods

3. Examples:
   - Count related objects: `Count('related_model')`
   - Sum related field: `Sum('related_model__field')`
   - Case expressions: `Case(..., When(...))`

4. Key characteristics:
   - Adds new fields to each object in the QuerySet
   - Preserves the ability to chain with other QuerySet methods
   - Useful for including derived fields in results

5. Syntax:
```
books = BookData.objects.annotate(chapters_count=Count('bookchapterdata'))

books = BookData.objects.annotate(total_pages=Sum('bookchapterdata__pages')) # when using foreign key

books = BookData.objects.annotate(
    popularity_status=Case(
        When(chapters_count__gt=10, then='Popular'),
        default='Not Popular',
        output_field=CharField()
    )
)
```

# Comparison
1. Purpose:
   - Aggregate: Summary statistics
   - Annotation: Derived fields for each object

2. Return value:
   - Aggregate: Single dictionary
   - Annotation: New QuerySet with additional fields

3. Chaining:
   - Aggregate: Not chainable
   - Annotation: Chainable with other QuerySet methods

4. Use cases:
   - Aggregate: Overall statistics, reporting
   - Annotation: Including derived fields in results, complex queries

5. Performance:
   - Aggregate: Generally faster for large datasets
   - Annotation: May impact performance for large datasets

Both Aggregate and Annotation are powerful tools for manipulating QuerySets in Django, serving different purposes in data analysis and query construction.

#TODO Subquery in Django

Here are some brief but detailed notes on using subqueries in Django, with examples:

#? Understanding Subqueries

- A subquery is a query nested within another query
- Allows retrieving data from one table based on results of another query
- Useful for complex filtering, aggregation, and joining operations
- Can lead to more concise and efficient code compared to multiple separate queries

#? Key Points

- Subqueries are part of `django.db.models`
- Commonly used with `Subquery()` and `OuterRef()` objects
- Can be used for filtering, annotating, and other query operations
- Often more efficient than multiple separate queries

#? Examples

1. Filtering based on subquery:

```
from django.db.models import Subquery, OuterRef

recent_posts = Post.objects.filter(published_date__gte=datetime.now()-timedelta(days=30))
popular_authors = Author.objects.filter(post__in=Subquery(recent_posts.values('author')))
```

2. Annotating with subquery:

```
from django.db.models import Count, Subquery

post_counts = Post.objects.filter(author=OuterRef('pk')).values('author').annotate(count=Count('id')).values('count')
authors_with_post_counts = Author.objects.annotate(post_count=Subquery(post_counts))
```

3. Using subquery with exists:

```
from django.db.models import Exists, OuterRef

active_users = User.objects.filter(last_login__gt=datetime.now()-timedelta(days=30))
inactive_user_ids = User.objects.exclude(
    Exists(active_users.filter(id=OuterRef('id')))
).values_list('id', flat=True)
```

#? Best Practices

- Use subqueries when dealing with complex relationships or aggregations
- Prefer subqueries over multiple separate queries for efficiency
- Combine with other Django ORM features like annotations and filters
- Test performance impact of subqueries on your specific dataset

By leveraging subqueries effectively, you can write more efficient and expressive database queries in Django.

#TODO Overwrite Save() Method in Django

Here are some brief but detailed notes on overriding the save() method in Django models, with examples:

#? Understanding save() Method

- The save() method is inherited from models.Model and is called when creating or updating a model instance
- It's executed when saving through admin interface, shell, or other methods
- Can be overridden to add custom behavior before or after saving to the database

#? Key Points

- Override save() in your model class
- Call super().save() at the end to actually save the instance
- Be cautious as errors in save() can prevent database saves

#? Examples

1. Auto-generating a slug:

```
from django.db import models
from django.utils.text import slugify

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)

    def save(self, *args, **kwargs):
        self.slug = slugify(self.title)
        super().save(*args, **kwargs)
```

2. Resizing an image before saving:

```
from django.db import models
from PIL import Image

class Product(models.Model):
    name = models.CharField(max_length=100)
    image = models.ImageField(upload_to='products/')
    
    def save(self, *args, **kwargs):
        if self.image:
            img = Image.open(self.image.path)
            img.thumbnail((100, 100))
            img.save(self.image.path)
        super().save(*args, **kwargs)
```

3. Sending email after save:

```
from django.db import models
from django.core.mail import send_mail

class Appointment(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()

    def save(self, *args, **kwargs):
        if self.pk is None:  # New instance
            send_mail(
                'New Appointment',
                f'Name: {self.name}\nEmail: {self.email}',
                'admin@example.com',
                ['notifications@example.com'],
                fail_silently=False,
            )
        super().save(*args, **kwargs)
```

#? Best Practices

- Use signals (pre_save, post_save) instead of overriding save() when possible
- Handle exceptions carefully in overridden save() methods
- Consider using properties or separate methods for complex logic
- Be aware of potential performance impacts with database operations in save()

* Refer Products model in models.py and generateSlug() from my utils.py

By understanding how to override the save() method, you can add custom behavior to your Django models, but use this feature judiciously as it can lead to more complex code if overused.

#TODO -> Bulk Create, Bulk Update and Bulk Delete in Django

#? Understanding Bulk Operations

- Bulk operations allow performing multiple database operations in a single query
- Significantly improves performance for large datasets compared to individual operations
- Available for create, update, and delete operations

#? Key Points

- Use `bulk_create()`, `bulk_update()`, and `bulk_delete()` methods
- Requires a list of model instances to operate on
- Can specify fields to update for bulk_update()
- Batch size can be controlled to optimize performance

#? Examples

1. Bulk Create:

```
new_objects = [Model(field1=value1, field2=value2) for _ in range(100)]
Model.objects.bulk_create(new_objects)
```

2. Bulk Update:

```
objects_to_update = Model.objects.all()[:100]
Model.objects.bulk_update(objects_to_update, ['field1', 'field2'])
```

3. Bulk Delete:

```
objects_to_delete = Model.objects.filter(condition).all()
Model.objects.bulk_delete(objects_to_delete)
```

#? Best Practices

- Use bulk operations for large sets of data to reduce database queries
- Be cautious with bulk delete as it permanently removes data
- Consider using transactions for atomicity in complex operations
- Profile performance to determine optimal batch sizes

#? Additional Features

- `ignore_conflicts=True` for bulk_create to skip existing entries
- `update_conflicts=True` for bulk_update to update existing entries
- `return_id=True` for bulk_create to return created IDs

* Refer bulk_operations_view from views.py
* Refer bulk_create_brands(), bulk_update_brands() and bulk_delete_brands() from my utils.py
* Refer bulk_operations.html from templates

By leveraging bulk operations, you can significantly improve the performance of data manipulation in Django, especially when dealing with large datasets.

#TODO -> Meta Class in Django

Here are some brief but detailed notes on the Meta class in Django models:

#? Understanding Meta Class

- The Meta class is an inner class within Django model classes
- Used to provide metadata and customization options for the model
- Optional, but commonly used to modify model behavior

#? Key Points

- Located inside the model class definition
- Provides various options to customize model behavior
- Does not inherit from any base class
- Accessed using model._meta syntax

#? Common Meta Options

1. Abstract models:
   ```
   class Meta:
       abstract = True
   ```

2. Table name:
   ```
   class Meta:
       db_table = 'custom_table_name'
   ```

3. Ordering:
   ```
   class Meta:
       ordering = ['-date_field']
   ```

4. Permissions:
   ```
   class Meta:
       permissions = (
           ('can_view_reports', 'Can view reports'),
       )
   ```

5. Verbose name:
   ```
   class Meta:
       verbose_name = 'User Account'
   ```

6. App label:
   ```
   class Meta:
       app_label = 'auth'
   ```

7. Proxy models:
   ```
   class Meta:
       proxy = True
   ```

#? Best Practices

- Use Meta for model-specific configurations
- Keep Meta simple and focused on model metadata
- Document custom Meta usage clearly
- Be consistent across similar models

#? Example

```
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)

    class Meta:
        ordering = ['-title']
        verbose_name = 'Book Title'
        db_table = 'books_custom'

    def __str__(self):
        return self.title
```

By utilizing the Meta class effectively, you can customize and enhance your Django models, improving their functionality and readability.

#TODO -> Soft Delete and Model Managers in Django

1. Soft Delete: This feature allows you to mark records as deleted without permanently removing them from the database. Instead, they are marked as deleted and can be restored if needed.
2. Model Managers: Model managers provide additional functionality for querying and manipulating your models. They can be used to perform complex queries or custom operations on your models.

```
class SkillManager(models.Manager):

    def get_queryset(self) -> models.QuerySet:
        return super().get_queryset().filter(is_deleted=False)


class Skills(models.Model):
    skill_name = models.CharField(max_length=100)
    is_deleted = models.BooleanField(default=False)

    objects = SkillManager() #! Setting SkillManager as default manager
    new_manager = models.Manager() #! Creating new manager and setting old default manager here

    def __str__(self):
        return self.skill_name
```

------------------------------------------------------------------------------

#! Project: Expense Tracker 

1. In this project, we will cover CRUD operations, aggregate functions, login logout and registration of users using Django. Also professional looking UI for templates.
2. Project: Expense
3. App: Tracker

------------------------------------------------------------------------------

#! Project: Full Text Search - Search Query, Search Rank and Search Vector. Also Implement TrigamSimilarity in Django

1. In this project, we will develop a Full Text Search algorithm using Search Query, Search Rank and Search Vector.
2. This will be possible only with Postgres Database as it supports search query, search rank and search vector.
3. Rank wise searching is needed to find the most relevant results and will be much faster compared to traditional searching.
4. We will use Django Debug Toolbar to see the time taken to execute the queries.

#? Full Text Search Algorithm
Full-text search (FTS) is a technique for searching and retrieving relevant documents based on the contents of the text. It involves three key components: the search query, which is the user's input; the search rank, which determines the relevance of each document based on factors like term frequency (TF) and inverse document frequency (IDF); and the search vector, which represents the query and documents as mathematical vectors for comparison. These elements work together to efficiently match and rank documents, using methods like TF-IDF, cosine similarity, and Boolean logic to provide accurate and relevant search results.

#* Full Text Search is a smaller version of Elastic Search. Full Text Search is feasible for low end servers whereas Elastic Search is used for large scale high end servers. Elastic Search requires minimum 8gb of RAM.

#TODO Add "django.contrib.postgres" to INSTALLED_APPS in settings.py

#? Trigram Similarity
Used to introduce fuzziness thus finding similar words in the database. It is a faster alternative to FTS. 
Example: User will get outout if he searches for "Cement" or "Cemnt" with spelling mistake.

#TODO Go to terminal and type "sudo -u postgres psql -d fulltextsearch", after logging in use "CREATE EXTENSION IF NOT EXISTS pg_trgm;" and verify its installation using "\dx"

------------------------------------------------------------------------------

#! Django Admin Interface

#? Customizing the Django Admin

* Refer admin.py from djangoadmin project

#? Customizing the look and feel of the Django Admin

#! Approach 1
* pip install django-admin-interface
* Add admin_interface and colorfield to INSTALLED_APPS

#! Approach 2
* pip install django-grappelli
* Add grappelli to INSTALLED_APPS
* Add "path("grappelli/", include("grappelli.urls"))," to urlpatterns
* python3 manage.py collectstatic

------------------------------------------------------------------------------

#! Django Middleware

#? Understanding the Django Middleware Deeply and Customizing middleware in Django

#? What is Middleware?

- Middleware acts as a layer between the request and response cycles
- It allows adding functionality to every request/response without modifying views
- Middleware components are stacked and processed in order

#? Key Functions of Middleware

1. Filtering Requests
   - Reject invalid or malicious requests early
   - Example: CSRF protection middleware

2. Modifying Requests/Responses  
   - Adding data to requests
   - Altering responses
   - Example: Authentication middleware adds user info to requests

3. Logging and Analytics
   - Tracking request/response data
   - Storing metrics
   - Example: Usage tracking middleware

#? Middleware Structure

- Two main methods:
  1. `__init__(get_response)` - Called once when server starts
  2. `__call__(request)` - Called for each request/response cycle

- Optional additional methods:
  - `process_view()`
  - `process_exception()`
  - `process_template_response()`

#? Registering Middleware

- Added to `MIDDLEWARE` setting in `settings.py`
- Order matters - affects execution sequence

#? Writing Custom Middleware

```
class MyMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        # Pre-process logic
        response = self.get_response(request)
        # Post-process logic
        return response
```

#? Best Practices

- Keep middleware lightweight
- Use built-ins when possible
- Order carefully to avoid conflicts
- Consider performance implications

#? Examples

1. Basic middleware:

```
class LogTimeMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        start_time = time.time()
        response = self.get_response(request)
        end_time = time.time()
        print(f"Request took {end_time - start_time:.2f}s")
        return response
```

2. Authentication middleware:

```
class AuthenticationMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        if 'user' not in request.session:
            # Redirect to login page
            pass
        return self.get_response(request)
```

1) Refer djangomiddleware project
2) Create middleware folder in project directory
3) Inside it create __init__.py and middleware.py
4) Create a middleware named IPBlockingMiddleware
5) Add "djmiddleware.middleware.middleware.IPBlockingMiddleware" to INSTALLED_APPS in settings.py
6) Write a view and url pattern to test it.

------------------------------------------------------------------------------

#! Project: Customizing middleware to accept custom headers

1) Refer djangomiddleware project
2) Create middleware folder in project directory
3) Inside it create __init__.py and middleware.py
4) Create a middleware named CheckBMPHeaderMiddleware
5) Add "djmiddleware.middleware.middleware.CheckBMPHeaderMiddleware" to INSTALLED_APPS in settings.py
6) Write a view and url pattern to test it.

------------------------------------------------------------------------------

#! Django User Authentication

#? Customizing the Django User Model

1) Refer djangoauthentication project
2) In models inherit the AbstractUser class from django.contrib.auth.models
3) In the new CustomUser model, add all the new required fields
4) Add "AUTH_USER_MODEL = "accounts.CustomUser"" to settings.py
5) Create a file named managers.py in the app directory and create a UserManager class inheriting from BaseUserManager
6) Add the CustomUser model to admin.py

-------------------------------------------------------------------------------

#! Django Advanced Stuff

#? Mastering Django Signals: A comprehensive guide

### Understanding Django Signals

- Signals are a way for different parts of a Django project to communicate
- Allow decoupled applications to react to events in other apps
- Follow a publisher-subscriber pattern

### Key Points

1. Signal Types
   - Model signals are of 4 types: pre_save, post_save, pre_delete, post_delete
   - Request/response signals

2. Signal Components
   - Sender: Object that emits the signal
   - Receiver: Function that responds to the signal

3. Signal Flow
   - Signal is sent by sender
   - Receivers execute in order they were connected

4. Connecting Signals
   - Using `@receiver` decorator
   - Manually connecting with `connect()` method

5. Signal Arguments
   - `sender`: The model class that triggered the signal
   - `instance`: The instance of the model
   - `**kwargs`: Additional keyword arguments

### Best Practices

- Use signals for decoupled communication between apps
- Keep signal handlers lightweight
- Order receivers carefully to avoid conflicts
- Consider using `weak=False` for long-lived receivers
- Use `sender` argument to ensure correct signal reception

#! Project: Automate Thumbnail Creation in Django using Signals

* Refer djangosignals/imageresizer project

1) In models.py, refer model named ImageModel
2) There are 4 signals: pre_save, post_save, pre_delete, post_delete
3) There are 2 components: sender and receiver
4) Register the models to admin and test it.